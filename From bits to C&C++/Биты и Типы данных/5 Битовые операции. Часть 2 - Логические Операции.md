## Логически переменные

Логических переменных всего 2 -- это 1 или Истина (True) и 0 или Ложь (False). Существует несколько базовых функций по работе с логическими переменными. Большинство АЛУ (арифметико-логическое устройство) предоставляют возможность с ними работать.

## AND функция

Таблица истинности:

| A   | B   | Результат AND |
| --- | --- | ------------- |
| 0   | 0   | 0             |
| 0   | 1   | 0             |
| 1   | 0   | 0             |
| 1   | 1   | 1             |
Для двоичных чисел операция будет производиться попарно и независимо для каждой пары бит исходных операндов. Такая операция называется побитовое И (bitwise AND). 
Например, $0011101001101001_{2}$ AND $0101100100100001_{2}$ = $0001100000100001_{2}$ 

Функцию AND можно использовать как битовую маску. Допустим, нам нужно за*маск*ировать (скрыть) часть бит, и оставить видимыми другие биты из одного битового шаблона. 
Например, есть битовый шаблон $01010110$ на нужно, чтобы в нем оставались только последние два бита. Можно использовать битовую маску $0000011$ и выполнить функцию AND между шаблоном и маской $01010110$ AND $0000011$ = $0000010$. Получившейся битовый шаблон будет отображать истинные значения только тех бит исходного шаблона, к которым в битовой маске по паре соответствовал бит равный 1.

## OR Функция

Таблица истинности:

| A   | B   | Результат OR |
| --- | --- | ------------ |
| 0   | 0   | 0            |
| 0   | 1   | 1            |
| 1   | 0   | 1            |
| 1   | 1   | 1            |
Так же, как и для функции AND, операция будет производиться попарно и независимо для каждой пары бит исходных операндов. Такая операция называется побитовое ИЛИ (bitwise OR). 

## NOT функция

Функция NOT (или функция отрицания) является унарной операцией - это значит, что она применяется только на один операнд.
Таблица истинности:

| A   | Результат NOT |
| --- | ------------- |
| 0   | 1             |
| 1   | 0             |

## Функция Exclusive-OR

Exclusive-OR или XOR (исключающее ИЛИ), также как и для функции AND и OR, операция будет производиться попарно и независимо для каждой пары бит исходных операндов. Такая операция называется побитовое ИЛИ (bitwise OR). 
Таблица истинности: 

| A   | B   | Результат XOR |
| --- | --- | ------------- |
| 0   | 0   | 0             |
| 0   | 1   | 1             |
| 1   | 0   | 1             |
| 1   | 1   | 0             |

XOR может быть очень полезен при сравнивании двух битовых шаблонов на идентичность. Если при применении XOR на два шаблона результатом являются все нули, то шаблоны идентичны.

## Закон де Моргана

Этот закон про преобразование логических выражений из одних в другие без потери результата:
* NOT (A AND B) == (NOT A) OR (NOT B)
* NOT (A OR B) == (NOT A) AND (NOT B)

## Битовый Вектор

В прошлых главах мы говорили, что целые числе могут представлены с дополнительным кодом, у которых есть свои правила преобразования и отображения битового шаблона (например, ведущий бит указывает на знак числа). 

Так вот битовый вектор - это битовый шаблон, с помощью которого можно определить/выделить свойства другого битового шаблона. Как например, битовая маска - задав маску в виде `0011` - мы скроем значения последних 2-х бит, применяемого через AND на маску битового шаблона `11010110 AND 00000011 = 00000010`. 

Еще один пример, допустим нам для 16-битного целого числа с доплнительным кодом нужно понимать является ли числа положительным или отрицательным, а также четное оно или нет. Тогда битовый вектор будет таким `1000000000000001`. При применении AND на число по результату ответ будет сразу ясен.