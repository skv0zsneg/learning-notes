Есть множество других способов представления информации в компьютере. Самые популярные, которые рассмотрены ниже - число с плавающей точкой (floating point data type) и коды ASCII. Также будет рассмотрено шестнадцатерчное представление битового шаблона для более human-readable представления.

## Число с плавающей точкой (floating point data type)

Подробнее 
- https://habr.com/ru/articles/112953/ - подробнее про [IEEE-754](https://standards.ieee.org/ieee/754/4211/)
- https://0.30000000000000004.com/ - почему 0.1 + 0.2 != 0.3

Как мы изучали ранее, для представления целых чисел используется 2's complement (дополнительный код) тип данных для представления целых чисел. Например, для 16 битного типа данных один бит определяет знак числа, а по оставшимся 15 битам определяются возможные значения от $-2^{15}=-32768$ до $2^{15}-1=32767$. 

Тут мы можем говорит, что точность (precision) наших значений 15 бит, а диапазон (range) $2^{16}$. Может сложится ситуация, когда у нас есть число, которое невозможно представить с данной точностью и диапазоном, например $6,022*10^{23}$. Самое большое число $2^{15} - 1$ сильно меньше необходимого $10^{23}$. С другой стороны, у нас достаточно бит для представления десятичной части (6022). Таким образом у нас появляется проблема: у нас больше чем необходимо бит, для точности; у нас недостаточно бит для диапазона.

Тип данных с плавающей точкой (float point) решает проблему. Вместо того, чтобы использовать все биты для представления точности, этот тип выделяет несколько бит для диапазона, а оставшиеся биты (за исключением одного для определения знака числа) отдаются точности. 

Множество ISA (Архитектур набора команд x86, ARM etc) представляют более одного типа данных с плавающей точкой. Один из них чащей всего называется *float* и имеет следующее разделение бит (для 32-х битного float).

![[Pasted image 20250429215152.png]]

Тут S - это знак, exponent - это экспонента(диапазон), а fraction - мантисса(точность).

### Нормализованная форма 

Число с плавающей точкой представлено в *основном* нормализованной форме, которая вычисляется следующим образом:
$N = (-1)^{S} * 1.fraction * 2^{exponent-127}, 1 <= exponent <= 254$ 
Здесь S, fraction и exponent - это битовые числа  

Мы говорим, что в *основном* нормализованной форме, потому что (как указано в формуле) число, представленное типом с плавающей точкой является нормализованным только если 8-бит экспоненты ограничены до 254 без знаковых целых чисел от 1 (00000001) до 254 (11111110).

Как известно 8 бит представляют 256 уникальных битовых шаблонов. Для экспоненты представлены только 254, а оставшиеся: 
* 0 (00000000) -- находится в диапазоне, если представляемое число является субнормальным, т.е. таким которое меньше $2^{-126}$ но больше нуля
* 1 (11111111) -- используются для представления бесконечности $+\infty$ если $S=0$ и $-\infty$ если $S=1$

### Вычисления

Для получения числа нужно воспользоваться формулой выше.

Пример. Какое значение для битового шаблона с типом floating point 
$$
00111101100000000000000000000000_{2}
$$
1. Ведущий бит 0, значит число положительное.
2. Следующие 8 бит ($01111011$) в десятичной системе - это 123. Вычитаем 123 - 127 и получаем экспоненту = -4.
3. Оставшиеся 32 бита нулевые.
4. Запишем решение $N = +1.00000000000000000000000 ⋅ 2^{-4} = \frac{1}{16}$ 

Пример. Какой представление в типе данных floating point имеет число $-6\frac58$?
1. Представим число $-6\frac58$ в двоичном виде: целая часть $6_{10}=110_2$, дробная часть $\frac{5}{8}_{10}=101_{2}$, объединяя учитывая знак $-110.101_{2}$.
2. Получаем значение мантиссы, "перенося" точку влево до тех пор, пока не останется слева от точки единственный не нулевой бит. При этом количество шагов "переноса" потом становится степенью двойки $-1.10101⋅2^2$ 
3. Зная степень двойки из шага 2, вычислим экспоненту $2+127=129$, что в двоичной системе равно $10000001_2$.
4. Запишем получившийся битовый шаблон отбросив ведущую единицу у точности: `1 100000001 10101000000000000000000`  

Онлайн калькулятор IEEE-754 - https://weitz.de/ieee/

---
*Не из книги*
## Почему 0.1 + 0.2 != 0.3?

Дело в том, что при преобразовании по IEEE-754 числа $0.1$ для floating point получается 
`0 01111011 10011001100110011001101` и если перевести это число обратно, то получается $≈0.0999999940395352$, что говорит о том, что при вычислении по floation point типу данных у чисел может теряется точность из-за чего конечные вычисления могут быть неверными.

В Python можно использовать тип `fractions.Fraction` для работы с дробными числами, однако от иррациональных числе все равно удастся уйти полностью.

Доп материал:
* https://0.30000000000000004.com/
* http://aco.ifmo.ru/el_books/numerical_methods/lectures/app_1.html - погрешности вычислений

---