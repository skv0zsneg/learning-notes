Есть множество других способов представления информации в компьютере. Самые популярные, которые рассмотрены ниже - число с плавающей точкой (floating point data type) и коды ASCII. Также будет рассмотрено шестнадцатерчное представление битового шаблона для более human-readable представления.

## Число с плавающей точкой (floating point data type)

Подробнее 
- https://habr.com/ru/articles/112953/ - подробнее про [IEEE-754](https://standards.ieee.org/ieee/754/4211/)
- https://0.30000000000000004.com/ - почему 0.1 + 0.2 != 0.3

Как мы изучали ранее, для представления целых чисел используется 2's complement (дополнительный код) тип данных для представления целых чисел. Например, для 16 битного типа данных один бит определяет знак числа, а по оставшимся 15 битам определяются возможные значения от $-2^{15}=-32768$ до $2^{15}-1=32767$. 

Тут мы можем говорит, что точность (precision) наших значений 15 бит, а диапазон (range) $2^{16}$. Может сложится ситуация, когда у нас есть число, которое невозможно представить с данной точностью и диапазоном, например $6,022*10^{23}$. Самое большое число $2^{15} - 1$ сильно меньше необходимого $10^{23}$. С другой стороны, у нас достаточно бит для представления десятичной части (6022). Таким образом у нас появляется проблема: у нас больше чем необходимо бит, для точности; у нас недостаточно бит для диапазона.

Тип данных с плавающей точкой (float point) решает проблему. Вместо того, чтобы использовать все биты для представления точности, этот тип выделяет несколько бит для диапазона, а оставшиеся биты (за исключением одного для определения знака числа) отдаются точности. 

Множество ISA (Архитектур набора команд x86, ARM etc) представляют более одного типа данных с плавающей точкой. Один из них чащей всего называется *float* и имеет следующее разделение бит (для 32-х битного float).

![[Pasted image 20250429215152.png]]

Тут S - это знак, exponent - это экспонента(диапазон), а fraction - мантисса(точность).

### Нормализованная форма 

Число с плавающей точкой представлено в *основном* нормализованной форме, которая вычисляется следующим образом:
$N = (-1)^{S} * 1.fraction * 2^{exponent-127}, 1 <= exponent <= 254$ 
Здесь S, fraction и exponent - это битовые числа  

Мы говорим, что в *основном* нормализованной форме, потому что (как указано в формуле) число, представленное типом с плавающей точкой является нормализованным только если 8-бит экспоненты ограничены до 254 без знаковых целых чисел от 1 (00000001) до 254 (11111110).

Как известно 8 бит представляют 256 уникальных битовых шаблонов. Для экспоненты представлены только 254, а оставшиеся: 
* 0 (00000000) -- находится в диапазоне, если представляемое число является субнормальным, т.е. таким которое меньше $2^{-126}$ но больше нуля
* 1 (11111111) -- используются для представления бесконечности $+\infty$ если $S=0$ и $-\infty$ если $S=1$

### Вычисления

Для получения числа нужно воспользоваться формулой выше.

Пример. Какое значение для битового шаблона с типом floating point 
$$
00111101100000000000000000000000_{2}
$$
1. Ведущий бит 0, значит число положительное.
2. Следующие 8 бит ($01111011$) в десятичной системе - это 123. Вычитаем 123 - 127 и получаем экспоненту = -4.
3. Оставшиеся 32 бита нулевые.
4. Запишем решение $N = +1.00000000000000000000000 ⋅ 2^{-4} = \frac{1}{16}$ 

Пример. Какой представление в типе данных floating point имеет число $-6\frac58$?
1. Представим число $-6\frac58$ в двоичном виде: целая часть $6_{10}=110_2$, дробная часть $\frac{5}{8}_{10}=101_{2}$, объединяя учитывая знак $-110.101_{2}$.
2. Получаем значение мантиссы, "перенося" точку влево до тех пор, пока не останется слева от точки единственный не нулевой бит. При этом количество шагов "переноса" потом становится степенью двойки $-1.10101⋅2^2$ 
3. Зная степень двойки из шага 2, вычислим экспоненту $2+127=129$, что в двоичной системе равно $10000001_2$.
4. Запишем получившийся битовый шаблон отбросив ведущую единицу у точности: `1 100000001 10101000000000000000000`  

Онлайн калькулятор IEEE-754 - https://weitz.de/ieee/

---
*Не из книги*
### Почему 0.1 + 0.2 != 0.3?

Дело в том, что при преобразовании по IEEE-754 числа $0.1$ для floating point получается 
`0 01111011 10011001100110011001101` и если перевести это число обратно, то получается $≈0.0999999940395352$, что говорит о том, что при вычислении по floation point типу данных у чисел может теряется точность из-за чего конечные вычисления могут быть неверными.

В Python можно использовать тип `fractions.Fraction` для работы с дробными числами, однако от иррациональных числе все равно удастся уйти полностью.

Доп материал:
* https://0.30000000000000004.com/
* http://aco.ifmo.ru/el_books/numerical_methods/lectures/app_1.html - погрешности вычислений

---

## ASCII Коды

Еще одно представление информации - это 8-битный ASCII (American Standart Code fir Inforamtion Interchange) код, который принят и поддерживается практически во всех компьютерных составляющих для передачи символов друг другу. 

Благодаря этому интерфейсу взаимодействие между клавиатурой от компании А, ПК от компании Б и монитором компании В сильно упрощается. Каждая клавиша на клавиатуре идентифицируется как уникальный ASCII код. Например, цифра 3 - это  `00110011`, а цифра 2 - это `00110010`, клавиша ENTER - это `00001101` и т.п. Когда определенная клавиша нажата ее 8 битный код сохраняется в компьютере для дальнейшего взаимодействия. 

Одна клавиша может быть связана с более чем одним кодом ASCII. Например, символ `E` - это `01000101`, а `e` - это `01100101` однако "отправить" эти коды с клавиатуры можно нажав одну и ту же клавишу (только в одном из случаев должна быть нажата CAPSLOCK или зажата SHIT).

## Шестнадцатеричное (hexadecimal) представление

Мы рассмотрели способы представления целых чисел - 2's complement, чисел с плавающей точкой - floating point, битовые вектора (например, битовая маска) и ASCII коды. Существует еще множество разных представлений, однако сейчас мы поговорим про представление, которое больше используется людьми для упрощения работы с двоичными числами - шестнадцатеричная нотация.

| Шестнадцатеричные цифры | Двоичные числа |
| ----------------------- | -------------- |
| 0                       | 0000           |
| 1                       | 0001           |
| 2                       | 0010           |
| 3                       | 0011           |
| 4                       | 0100           |
| 5                       | 0101           |
| 6                       | 0110           |
| 7                       | 0111           |
| 8                       | 1000           |
| 9                       | 1001           |
| A                       | 1010           |
| B                       | 1011           |
| C                       | 1100           |
| D                       | 1101           |
| E                       | 1110           |
| F                       | 1111           |


Это может полезно, например а таких случаях. Есть число с дополнительным кодом `0011110101101110`, если мы его разобьем на 4 части - `0011 1101 0110 1110` и преобразуем в шестднацатиричное значение, то получим `3D6E`. По получившемуся значению можно сразу понять какой знак у числа.