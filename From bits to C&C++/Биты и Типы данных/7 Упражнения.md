
## 2.1

*Задача*: Дано $n$ бит. Сколько уникальных комбинаций существует для $n$ бит?
*Решение*: Количество уникальных комбинаций можно получить по формуле $2^n$ 

## 2.2

*Задача*: В английском алфавите 26 символов. Какое наименьшее число бит необходимо для описания всех символов уникальным битовым паттерном? А сколько нужно бит, чтобы также определить заглавные буквы?

*Решение*: 

Так как всего 26 символов, то нужно иметь 26 уникальных битовых паттернов. По формуле $2^n$ можно вычислить количество комбинаций для $n$ бит. Получается, что минимальное количество бит - это 5, так как это будет $2^5=32$ комбинации, что покрывает количество символов а алфавите.

Если мы должны учитывать и символы в верхнем регистре, то количество символов увеличивается в 2 раза и равно 52. Тогда минимальное количество необходимых бит для описания всех символов равно 6 так как $2^6=64$ покрывает все символы.

## 2.3

*Задача*:

а) Представь, что у тебя 400 студентов в классе. Если каждому из них присвоить уникальный битовый паттерн, то какое минимальное количество бит для этого необходимо?
б) Сколько можно добавить студентов в класс без изменения установленного количества бит?

*Решение*:

а) Минимальное количество бит равно 9, так как $2^9=512$ комбинаций, что покрывает количество учеников в классе.
б) Без изменения количества бит можно добавить $512-400=112$ студентов.

## 2.4

*Задача*: Дано $n$ бит, как много без знаковых целых чисел можно представить $n$ битами? Какой диапазон этих чисел?

*Решение*: Количество чисел можно вычислить как $2^n$, например для 4 бит количество знаковых целых чисел равно $2^4=16$. 
Для диапазона вычислим максимальное значение целого без знакового $2^{n-1} + 2^{n-2} + ... + 2^{n-n}$ или $2^n-1$. Например, для $n=4$ максимальным целым без знаковым числом будет $2^3 + 2^2 + 2^1 + 2^0 = 15$ или $2^4-1 = 15$. Число меньше на единицу так как мы *учитываем* 0. Диапазон целых без знаковых чисел будут значения от 0 до $2^n-1$.

## 2.5

*Задача*: Используя 5 бит для представления каждого числа напиши представления для 7 и -7 для дополнения до 1-го (1's complement) и для дополнения до 2-х (2's complement).

*Решение*:

В 1's complement для определения знака числа используется ведущий бит 0 - число положительное, 1 - число отрицательное, а также если число отрицательное то оно должно быть "реверсированым" вариантом положительного числа.

| 7     | -7    |
| ----- | ----- |
| 00111 | 11000 |

В 2's complement также ведущий бит указывает на знак числа, однако для представления отрицательного числа биты положительного числа "реверсируются" **и** к получившейся последовательности добавляется 1. 

| 7     | -7    |
| ----- | ----- |
| 00111 | 11001 |

> ℹ️ Преимущества 2's над 1's complement - это отсутствие 2-х нулей 00000 и 11111 (отрицательные ноль), проще аппаратная реализация.

## 2.6

*Задача*: Напишите 6 битовое представление числа -32 в 2's complement.

*Решение*: 

Следуя алгоритму преобразования представим число с положительным знаком в двоичной системе $100000$. Далее "реверсируем" все биты и прибавим единицу. `011111 + 1 = 100000`. Получилось тоже самое число, что и положительное, однако оно равно -32 в 2's complement.

Дело в том, что диапазон для 2's complement определяется как $[-2^{n-1}, 2^{n-1}-1]$ для 6 бит получается $[-32, 31]$. Получается, что положительное число 32 не умещается в заданное количество бит, но -32 вмещается.

## 2.7

*Задача*: создай таблицу со всеми десятичными значениями для всех 4-х битовых 2's complement

*Решение*:

| Десятичное | 2's complement |
| ---------- | -------------- |
| 0          | 0000           |
| 1          | 0001           |
| 2          | 0010           |
| 3          | 0011           |
| 4          | 0100           |
| 5          | 0101           |
| 6          | 0110           |
| 7          | 0111           |
| -8         | 1000           |
| -7         | 1001           |
| -6         | 1010           |
| -5         | 1011           |
| -4         | 1100           |
| -3         | 1101           |
| -2         | 1110           |
| -1         | 1111           |

## 2.8

*Задача*: 

а) Какое самое больше положительное число можно представить в 8 битном дополнительном коде? Напишите ответ в двоичной и десятичной системе счисления.
б) Какое самое больше отрицательное число можно представить в 8 битном дополнительном коде? Напишите ответ в двоичной и десятичной системе счисления.
в) Какое самое больше положительное число можно представить в n битном дополнительном коде?
г) Какое самое больше отрицательное число можно представить в n битном дополнительном коде?

*Решение*:

а) По формуле $2^{n-1}-1$  получим, что самое большое положительное число в десятичной системе будет $2^{8-1}-1 = 127$, в двоичной $01111111$ 
б) По формуле $-2^{n-1}$  получим, что самое большое положительное число будет 
$-2^{8-1} = -128$, в двоичной $1000000$ 
в) Самое больше положительное число можно определить по формуле $2^{n-1}-1$
г) Самое больше положительное число можно определить по формуле $-2^{n-1}$

## 2.9

*Задача*: сколько необходимо бит для представления числа Авагардо $6.02 ⋅ 10^{23}$ в дополнительном коде?

*Решение*: хоть число и больше и его вряд ли можно представить в дополнительно коде на реальной машине, тем не менее посчитать количество необходимых для него бит возможно. Пусть число $6.02 ⋅ 10^{23}$ самое больше для битовой последовательности. Тогда,  
1) $2^{n-1}-1 = 6.02 ⋅ 10^{23}$
2) $2^{n-1} = 6.02 ⋅ 10^{23} + 1$
3) $2^{n-1} ≈ 6.02 ⋅ 10^{23}$ пренебрегаем единицей,  потому что значение справа очень велико  
4) $log_{2}(2^{n-1})≈log_{2}(6.02 ⋅ 10^{23})$ для избавления от степеней преобразуем обе части уравнения к логарифму по основанию 2
5) Левая часть: $log_{2}(2^{n-1})=(n-1)⋅log_{2}(2)=n-1$ преобразование по свойству логарифмов 
6) Правая часть: $log_{2}(6.02 ⋅ 10^{23})=log_{2}(6.02) + 23log_{2}(10)$ преобразование по свойству логарифмов
7) $n-1≈log_{2}(6.02) + 23log_{2}(10); n-1≈2.59+23⋅3.32193; n≈79.994≈80$ 
Получаем, что для представления числа Авагардо необходимо 80 бит.

## 2.10

*Задача*: преобразуй следующие двоичные числа в дополнительном коде в десятичные
а) $1010$
б) $01011010$
в) $11111110$
г) $0011100111010011$

*Решение*:

а) $1010$
Инвертируем все биты, прибавим один бит, преобразуем к десятичному, учтем минус:
$0101_2$, $0101_2 + 1_2 = 0110_2$, $0110_2 = 2^3⋅0+2^2⋅1+2^1⋅1+2^0⋅0 = -6_{10}$

б) $01011010$
Преобразуем к десятичному:
$01011010_2 = 2^7⋅0+2^6⋅1+2^5⋅0+2^4⋅1+2^3⋅1+2^2⋅0+2^1⋅1+2^0⋅0 = 90_{10}$

в) $11111110$
Инвертируем все биты, прибавим один бит, преобразуем к десятичному, учтем минус:
$00000001$, $00000001_2 + 1_2 = 00000010_2$, $... + 2^1⋅1 + 2^0⋅0 = -2_10$

г) $0011100111010011$
Преобразуем к десятичному:
$0011100111010011_2 = 2^{13}⋅1 + 2^{12}⋅1 + 2^{11}⋅1 ... + 2^8⋅1 + 2^7⋅1 + 2^6⋅1 + ... + 2^4⋅1 + ... + 2^1⋅1 + 2^0⋅1 = 14803_{10}$
## 2.11

*Задача*: преобразуйте следующие десятичные числа в 8-битные двоичные по дополнительному коду
а) $102$
б) $64$
в) $33$
г) $-128$
д) $127$

*Решение*:

а) $102$
Преобразуем к двоичному
102/2=0
51/2=1
25/2=1
12/2=0
6/2=0
3/2=1
1/2=1
По остаткам снизу вверх и ведущий бит - знак числа: $01100110$

б) $64$
Преобразуем к двоичному
64/2=0
32/2=0
16/2=0
8/2=0
4/2=0
2/2=0
1/2=1
По остаткам снизу вверх и ведущий бит - знак числа: $01000000$

в) $33$
Преобразуем к двоичному
33/2=1
16/2=0
8/2=0
4/2=0
2/2=0
1/2=1
По остаткам снизу вверх и ведущий бит - знак числа: $00100001$

г) $-128$
Преобразуем к двоичному, отнимем один бит, инвертируем биты,
128/2=0
64/2=0
32/2=0
16/2=0
8/2=0
4/2=0
2/2=0
1/2=1
10000000 -> 01111111 -> $10000000_{2}$

д) $127$
Преобразуем к двоичному
127/2=1
63/2=1
31/2=1
15/2=1
7/2=1
3/2=1
1/2=1
01111111 

## 2.12

*Задача*: Если последняя цифра битовой последовательности в дополнительном коде равна нулю, тогда число четное. Если последние две цифры битовой последовательности в дополнительном коде - это 00 (например $01100$), что это говорит вам о числе?

*Решение*: 

Возьмем примеры бинарных чисел в дополнительном коде с двумя нулями на конце

| Двоичная | Десятичная |
| -------- | ---------- |
| 00000    | 0          |
| 00100    | 4          |
| 01000    | 8          |
| 01100    | 12         |
| 10000    | -32        |
| 10100    | -16        |
| 11000    | -8         |
| 11100    | -4         |
У всех числе общее свойство - это то, что они все кратны 4-м. Точно также как последний ноль говорит о том, что число четное (т.е. делится на 2), два нуля на 4 и так далее.

## 2.13

*Задача*: Без изменения значений преобразуй следующие битовые числа в дополнительном коде в 8-и битные числа в дополнительном коде

а) $1010$
b) $011001$
c) $111111100$
d) $01$

*Решение*:
В случае дополнительного кода, необходимо сделать знаковое расширение для числа - дописать 0 для положительного числа и 1 для отрицательного:
a) $1010$ -> $11111010$
Из-за того, что число отрицательное оно дополняется битами равными единице.
b) $011001$ -> $00011001$
c) $111111100$ -> $11111100$ 
В данном случае преобразования до 8-и бит обрежет число сместив ведущий бит вправо но само число не изменится. Однако, обрезание последовательности бит может изменить значение в таком варианте $011111100$ != $01111100$ 
d) 01 -> 00000001

## 2.14

*Задача*: Сложи следующие битовые паттерны
*Решение*:
а) $1011$ + $0001$ = $1100$
b) $0000$ + $1010$ = $1010$
c) $1100$ + $0011$ = $1111$
d) $0101$ + $0110$ = $1011$
e) $1111$ + $0001$ = $10000$


## 2.15

*Задача*: известно, что битовый сдвиг влево умножает число на два. А какая операция производится над числом при битовом сдвиге вправо?
*Решение*: $01101_{2} = 13_{10}$, $00110 = 6_{10}$, $00011 = 3_{10}$ судя  по динамике изменений чисел -- это операция целочисленного деления на 2 с отбрасыванием остатка.

## 2.16

*Задача*: напишите решение следующих сложений в двоичном 8-битовом и десятичном счислении. При этом используйте обычной сложение бинарных паттернов.

*Решение*:

a) Сложить 1's complement представление числа 7 с 1's complement представлением числа -7
7 -> $00000111_{2}$ 
-7 -> $11111000_{2}$ 
$00000111_{2} + 11111000_{2} = 11111111_{2} = -0_{10}$ (в переводе с 1's complement)

b) Сложить signed magnitude представление 7 с signed magnitude -7
 7 -> $00000111_{2}$
 -7 -> $10000111_{2}$
 $00000111_{2} + 10000111_{2} = 10001000_{2} = -8_{10}$ (в переводе с signed magnitude)

c) Сложить представление 7 в дополнительном коде с -7 в дополнительном коде
7 -> $00000111_{2}$
-7 -> $11111001_{2}$
$00000111_{2} + 11111001_{2} = 000000000_{2} = 0_{10}$ (в переводе с дополнительного коде) так как у нас ограничение на 8 бит

## 2.17

*Задача*: Сложи следующие двоичные числа с дополнительным кодом. Запиши результат в двоичном и десятичном счислении.
*Решение*:

>ℹ️ Нюанс в *знаковом расширении*

a) $01 + 1011 = 0001 + 1011 =1100_{2}; -4_{10}$
b) $11 + 01010101 = 11111111 + 01010101 = (1)01010100_{2};84_{10}$ - тут отбрасывается доп бит слева, потому что работаем с 8-и битными числами.
c) $0101 + 110 = 0101 + 1110 = (1)0011_{2};3_{10}$ - тут тоже отбрасывается доп бит слева, потому что работаем с 4-х битными числами.
d) $01 + 10= 11_{2};-1_{10}$


## 2.18

*Задача*: Сложи следующие двоичные беззнаковые целые числа. Запиши результат в двоичном и десятичном счислении.
*Решение*:
a) $01 + 1011 = 0001 + 1011 = 1100_{2}; 12_{10}$
b) $11 + 01010101 = 00000011 + 01010101 = 01011000_{2};88_{10}$
c) $0101 + 110 = 0101 + 0110 = 1011_{2};11_{10}$
d) $01 + 10= 11_{2};3_{10}$


## 2.19

*Задача*: Представь отрицательно число -27 в дополнительно коде размером 8 бит, затем 16 бит и 32 бита. Что это показывает в отношении свойств знакового расширения для дополнительного знака?
*Решение*:
Представим 27 в двоичной системе счисления:
27/2=1
13/2=1
6/2=0
3/2=1
1/2=1
$11011_{2}$
- 8 бит. $00011011_{2}$ -> $00011010_{2}$ -> $11100101_{2}$
- 16 бит. $0000000000011011_{2}$ -> $0000000000011010_{2}$ -> $1111111111100101_{2}$
- 32 бит. $00000000000000000000000000011011_{2}$ -> $00000000000000000000000000011010_{2}$ -> $11111111111111111111111111100101_{2}$

Это показывает, что ведущий бит, указывающий знак числа, расширяется в зависимости от битовой размерности, но его начало всегда остается на одном и том же бите.
При знаковом расширении ведущий бит (знаковый) копируется в новые старшие позиции, чтобы сохранить значение и знак числа в большей разрядности.

## 2.20

*Задача*: Представлены 4-х битные числа с дополнительным кодом. Какая из операций вызовет переполнение? Обоснуйте ответ приведя операнды и результат к десятичному счислению.
*Решение*:
a) $1100_{2};-4_{10} + 0011_{2};3_{10} = 1111_{2};-1_{10}$ - тут нет переполнения.
b) $1100_{2};-4_{10} + 0100_{2};4 = (1)0000_{2};0_{10}$ - тут нет переполнение.
c) $0111_{2};7_{10}+0001_{2};1_{10}=(0)1000_{2};-8_{10}$ - тут переполнение.
d) $1000_{2};-8_{10} - 0001_{2};1_{10} = (1)0111_{2};7_{10}$ - тут переполнение.
e) $0111_{2};7_{10}+1001_{2};-7_{10} = (1)0000;0_{10}$ - тут нет переполнения.

## 2.21

*Задача*: Опиши, какие условия свидетельствуют о переполнении, когда складываются два двоичных числа с дополнительным кодом.
*Решение*: Когда в результате сложения двух отрицательных получается положительное и наоборот, при сложении двух положительных получается отрицательное. Если знаки у чисел разные, то переполнение никогда не наступит.

## 2.22

*Задача*: Создайте два 16 битных числа с дополнительным кодом, чья сумма приведет к переполнению.
Решение: 
- $0111111111111111_{2} + 0000000000000001_{2} = 1000000000000000_{2}  (-32768_{10})$
- $32767_{10}+1_{10}=32768_{10}$
Результат сложения должен быть больше нуля.

## 2.23

*Задача*: Опиши условия для сложения двух беззнаковых двоичных чисел, которые сигнализируют о переполнении.
*Решене*: 
- В случае, когда для результата сложения требуется больше бит, чем выделено. Например, сложение двух 4-х битных беззнаковых чисел $1111_{2} + 0001_{2} = 10000_{2}$ - результат не умещается в 4 бита, значит произошло переполнение. 
- В случае, когда результат суммы превышает максимально возможное число $a_{2} + b_{2} > 2^{n} - 1$, где n - битовая размерность.

## 2.24

*Задача*: Создайте два 16 битных беззнаковых числа, сумма которых приведет к переполнению.
*Решение*:
- $1111111111111111_{2} + 0000000000000001_{2} = 10000000000000000_{2}$
Максимально возможное число для 16 битного беззнакового - это $2^{16} - 1 = 65535_{10}$ 
Получившаяся сумма выше больше максимального $65536_{10} > 65535_{10}$ значит произошло переполнение.

## 2.25

*Задача*: Почему сумма отрицательного и положительно числа с дополнительным кодом никогда не вызовет переполнения?
*Решение*: Потому что, какими бы не были значения этих чисел результат суммы будет всегда находится между ними, а значит не вызовет переполнения.

## 2.26

*Задача*: Вы хотите представить число $-64$ как двоичное число с дополнительным кодом.
а) Сколько минимум бит для этого понадобиться? 
б) С этим количеством бит, какое самое больше положительное число можно получить? Ответ в двоичной и десятичной системе.
в) С этим количеством бит, какое самое больше беззнаковое число можно получить? Ответ в двоичной и десятичной системе.

*Решение*:
а) Переведем $-64$ в дополнительный код. Перевести число в дополнительный код так, как будто оно положительное $01000000_{2}$ -> отнять один бит -> $00111111_{2}$ -> реверсировать биты -> $11000000_{2}$. Таким образом, минимум необходимо 8 бит для записи числа.
б) Самое больше позитивное число в дополнительном коде равно $2^{8 - 1} - 1 = 127_{10}, 01111111_{2}$
в) Самое большое беззнаковое число будет равно $255_{10},11111111_{2}$ 

## 2.27

*Задача*: LC-3 - это 16 битная машина. На ней были сложены два числа с дополнительным кодом и получен результат:
$$
0101010101010101_{2} + 0011100111001111_{2} = 1000111100100100_{2}
$$
Есть ли тут какая-то проблема? Если да, то какая. Если нет, то почему нет?

*Решение*:
Проблема есть и заключается в переполнении при сложении. При сложении двух положительных чисел должно получиться положительное число, однако в решении выше получается отрицательное. Это можно заключить по ведущему биту в результате сложения равному 1. 

## 2.28

*Задача*: В каких случаях результат операции с AND дает 1?
*Решение*: При двух операндах равных 1. 1 AND 1 = 1.

## 2.29

*Задача*: Заполните таблицу истинности для AND операции.
*Решение*:

| X   | Y   | X AND Y |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 0       |
| 1   | 0   | 0       |
| 1   | 1   | 1       |

## 2.30

*Задача*: Решите следующие уравнения. Запишите результат в двоичной системе счисления
*Решение*:
а) 01010111 AND 11010111 = 01010111
б) 101 AND 110 = 100
в) 11100000 AND 10110100 = 10100000
г) 00011111 AND 10110100 = 00010100
д) (0011 AND 0110) AND 1101 = 0010 AND 1101 = 0000
е) 0011 AND (0110 AND 1101) = 0011 AND 0100 = 0000

## 2.31

*Задача*: В каких случаях операция с OR дает 1?
*Решение*: В случаях, когда один из операндов или оба равны 1. Например, 0 OR 1 = 1

## 2.32 

*Задача*: Заполните таблицу истинности для OR
*Решение*:

| X   | Y   | X OR Y |
| --- | --- | ------ |
| 0   | 0   | 0      |
| 0   | 1   | 1      |
| 1   | 0   | 1      |
| 1   | 1   | 1      |

## 2.33

*Задача*: Решите следующие уравнения. Запишите результат в двоичной системе счисления

*Решение*:
а) 01010111 OR 11010111 = 11010111
б) 101 OR 110 = 111
в) 11100000 OR 10110100 = 1110100
г) 11100000 OR 10110100 = 11110100
д) (0101 OR 1100) OR 1101 = 1101 OR 1101 = 1101
е) 0101 OR (1100 OR 1101) = 0101 OR 1101 = 1101

## 2.34

*Задача*: Решите следующие уравнения. Запишите результат в двоичной системе счисления

*Решение*:
а) NOT(1011) OR NOT(1100) = 0100 OR 0011 = 0111
б) NOT(1000 AND (1100 OR 0101)) = NOT(1000 AND 1101) = NOT(1000) = 0111
в) NOT(NOT(1101)) = NOT(0010) = 1101
г) (0110 OR 0000) AND 1111 = 0110 AND 1111 = 0110

## 2.35

*Задача*: Для чего используется битовая маска из примера 2.11 (стр. 43)?

*Решение*: В данном примере битовая маска используется для установки идентификации для машин в статус "активный" и "неактивный". Это достигается операциями AND (для отключения) OR (для включения) юнитов: BUSYNESS `11000010` AND Mask `01111111` = `01000010` 7-я машина (бит) отключена; BUSYNESS `01000010` OR `00100000` = `01100010` 5-я машина (бит) включена.

## 2.36

*Задача*: С ссылкой на пример 2.11 (стр. 43) ответьте на следующие вопросы:

*Решение*:

а) Какую маску и операцию нужно использовать, чтобы показать что машина 2 занята
BUSYNESS `11000010` AND Mask `11111101` = `11000000` 2-я машина (бит) отключена.

б) Какую маску и операцию использовать, чтобы показать, что машина 2 и 6 больше не  заняты.
BUSYNESS `11000000` OR Mask `00100010` = `11100010` 2-я и 6-я машины (бит) доступны.

в) Какую маску и операцию использовать, чтобы показать, что все машины заняты.
BUSYNESS `11100010` AND Mask `00000000` = `00000000` все машины заняты.

г) Какую маску и операцию использовать, чтобы показать, что все машины доступны.
BUSYNESS `00000000` OR Mask `11111111` = `11111111` все машины доступны.

д) Используя все операции выше создайте процедуру, которая выделяет статус машины 2 в ведущий бит. Например, для BUSYNESS `01011100` результат должен быть `10000000`, для BUSYNESS `01110011` результат должен быть `00000000`.

Тут можно скомбинировать 3-и подхода: применение маски, сложение битовых векторов, переполнение.
((BUSYNESS `b7 b6 b5 b4 b3 b2 b1 b0` AND `0 0 0 0 0 1 0 0`) + `0 1 1 1 1 0 0 0`) AND `1 0 0 0 0 0 0 0 0`
Примеры решений:
1) ((BUSYNESS `01011100` AND `00000100`) + `01111000`) AND `10000000` = (`00000100` + `01111000`) AND `10000000` = `10000000` AND `10000000` = `10000000`
2) ((BUSYNESS `01110011` AND `00000100`) + `01111000`) AND `10000000` = (`00000000` + `01111000`) AND `10000000` = `01111000` AND `10000000` = `00000000`

Есть более изящное решение с помощью побитового сдвига:
 `b7 b6 b5 b4 b3 b2 b1 b0`>> 2 = `0 0 b7 b6 b5 b4 b3 b2`
 `0 0 b7 b6 b5 b4 b3 b2` << 7 = `b2 0 0 0 0 0 0 0`

## 2.37 ❌

*Задача*: Пусть $n$ и $m$ оба 4-х битные числа с дополнительным кодом, а $s$ - это 4-х битный результат их сложения. Как мы можем определить (используя только логические операции из секции 2.6) что произошло переполнение? Создайте процедуру, на вход которой будет $n$, $m$ и $s$ а на выходе 4-х битовый паттерн полный нулей, если переполнения не было или с ведущим положительным битом если переполнение было.

*Решение*:
Показателем переполнения при сложении является смена знака, например если складывается два положительных числа никак не может получиться отрицательное и наоборот. При этом сложение чисел с разными знаками никогда не вызовет переполнения.
$n+ m = s$ 

$n_{3}n_{2}n_{1}n_{0}$ AND $1000_{2}$ = $n_{3}000_{2}$
$m_{3}m_{2}m_{1}m_{0}$ AND $1000_{2}$ = $m_{3}000_{2}$
$s_{3}s_{2}s_{1}s_{0}$ AND $1000_{2}$ = $s_{3}000_{2}$
1000 XOR 1000 = 0000 + 1000 = 1000
1000 XOR 0000 = 1000 + 1000 = 1000

Нужен XOR для того, чтобы определить что знак сменился - знак должен быть 0 в результате 1? -> 0 xor 1 = 1000 
Как посчитать знак, который должен быть? 1 и 1 должен быть 1, 0 и 0 должен быть 0
???

## 2.38 ❌

*Задача*: Пусть $n$ и $m$ оба 4-х битных беззнаковых числа, а $s$ - это 4-х битный результат их сложения. Как мы можем определить (используя только логические операции из секции 2.6) что произошло переполнение? Создайте процедуру, на вход которой будет $n$, $m$ и $s$ а на выходе 4-х битовый паттерн полный нулей, если переполнения не было или с ведущим положительным битом если переполнение было.

*Решение*: ???

## 2.39

*Задача*: Напишите представления IEEE числа с плавающей точкой для с следующих чисел в десятичной системе счисления:

*Решение*:
а) $3.75$ 
1. Переведем в двоичную систему число:
	1. 3 -> 11
	2. 0.75 -> 110
		1. 0.75 * 2 = **1**.5
		2. 0.5 * 2 = **1**
		3. 0 * 2 = **0**
	3. 11 + 110 = $11.11_{2}$ 
2. Сдвигаем точку влево до тех пор, пока слева от точки не останется единственный не нулевой бит:
	1. $11.11_{2}$ -> $1.111_{2}$
3. Определяем знака числа (первый бит): 0 так как число положительное
4. Порядок (экспонента): (1 так как мы сдвинули точку один раз) $1_{10}$ + 127 = 128 = $10000000_{2}$ 
5. Мантисса (дробная часть, та что после запятой): $111_{2}$ нужно дополнить до 23 бит -> $11100000000000000000000_{2}$ 
Таким образом, получаем $3.75_{10}$ = $0$ $10000000$ $11100000000000000000000$

б) $-55 \frac{23}{64}$ 
1. Переведем число в двоичную систему:
	1. 55 -> 110111
	2. $\frac{23}{64} = 0.359375$ -> 0.010111
	3. 110111 + 010111 = 110111.010111
2. Сдвигает точку влево:
	1. 110111.010111 -> 1.10111010111
3. Определяем знак числа: 1, так как число отрицательное
4. Экспонента: (5 так как мы сдвинули точку один раз) 5 + 127 = 132 = $10000100_{2}$ 
5. Мантисса: 10111010111 и дополнить до 23 бит -> 10111010111000000000000
Таким образом получаем: $-55 \frac{23}{64}$ -> $1$ $10000100$ $10111010111000000000000$

в) $3.1415927_{10}$
1. Переведем число в двоичную:
	1. 3 -> 11
	2. 0.1415927 -> 0.0010010000111111011010 (с точностью 24 бит)
	3. 11 + 0.00100100001111110110101 = 11.0010010000111111011010
2. Сдвигаем точку влево: 1.10010010000111111011010
3. Знак числа: 0
4. Экспонента: (1 так как мы одни раз передвинули запятую) 1 + 127 = 128 = $10000000_{2}$
5. Мантисса: 10010010000111111011010
Таким образом получаем: $3.1415927_{10}$ -> $0$ $10000000$  $10010010000111111011010$

г) 64.000
1. Переведем число в двоичную систему:
	1. 64 -> 1000000
	2. $0.0_{10}$ -> $0.0_{2}$
	3. 1000000 + 0.0 = 1000000.0 
2. Сдвигаем точку влево: 1000000.0 -> 1.0000000
3. Знак числа: 0
4. Экспонента: (6 так как мы 6 раз перенесли точку) -> 6 + 127 = 133 -> 10000101
5. Мантисса: 0000000 дополняем до 23 бит -> 00000000000000000000000
Таким образом 64.000 -> 0 10000101 00000000000000000000000

## 2.40

*Задача*: Напишите десятичные эквиваленты следующих IEEE 745 чисел с плавающей точкой

*Решение*:
a) 0 10000000 00000000000000000000000
1. Знак числа: 0 - значит +
2. Экспонента: 10000000 -> 128 - 127 = 1
3. Мантисса: 1 + 0.0 = 1.0
4. Вычисление: 1.0 * $2^{1}$ = 2.0
Таким образом 0 10000000 00000000000000000000000 -> $2_{10}$

б) 1 10000011 00010000000000000000000
1. Знак числа: 1 - значит -
2. Экспонента: 10000011 ->  131 - 127 = 4
3. Мантисса: 1 + 0.0625 = 1.0625
4. Вычисление: -1 * 1.0625 * $2^{4}$ = -17
Таким образом 1 10000011 00010000000000000000000 -> -17

в) 0 11111111 00000000000000000000000
1. Знак числа: 0 - значит +
2. Экспонента: так как экспонента равна 11111111, значит что число равно бесконечности 
Таким образом 0 11111111 00000000000000000000000 -> $+\infty$ 

г) 1 10000000 10010000000000000000000
1. Знак числа: 1 - значит -
2. Экспонента: 10000000 -> 128 - 127 = 1
3. Мантисса: 1 + 0.5625 (перевод в десятичную 0.1001 - мантиссы) = 1.5625
4. Вычисление: -1 * 1.5625 * $2^{1}$ = -3,125
Таким образом, 1 10000000 10010000000000000000000 -> -3,125

## 2.41

*Задача*:
а) Какая самая большая возможная экспонента для 32-х битного IEEE числа с плавающей точкой?
б) Какая самая наименьшая возможная экспонента для 32-х битного IEEE числа с плавающей точкой?

*Решение*:
а) Числовое значение смещенной экспоненты может быть до $254_{10}$, а истинной $127_{10}$. Если же оно равно 255, то, при мантиссе равной 0 обозначают $\infty$, если мантисса != 0 то это NaN
б) Минимальное значение смещенной экспоненты может быть до $1_{10}$, а истинной $-126_{10}$. Если оно равно 0, то число является денормализованным (чтобы это, блять, не значало) или равно нулю.

## 2.42

*Задача*: программист написал программу, которая складывает два числа. Он запустил ее сложив два числа 8 и 5, но в результате получил символ `m`. Объясните, почему программа себя так повела?

*Решение*: 
Скорее всего на вход программе были переданным ASCII сиволы чисел и был считан их код, а не фактическое значение. `'8'` в ASCII - это 00111000, а `'5'` - это 00110101. При их сложении получается 00111000 + 00110101 = 01101101, что является ASCII кодом символа `m`.

## 2.43

Задача: Переведите следующие ASCII коды в строки символов интерпретируя каждую группу 8 бит как 1 ASCII символ.

*Решение*:
а) 0x48656C6C6F21
1. $48_{16}$ -> $01001000_{2}$  -> `H`
2. $65_{16}$ -> $01100101_{2}$  -> `e`
3. $6C_{16}$ -> $01101100_{2}$  -> `l`
4. $6C_{16}$ -> $01101100_{2}$  -> `l`
5. $6F_{16}$ -> $01101111_{2}$  -> `o`
6. $21_{16}$ -> $00100001_{2}$  -> `!`
Получается: 0x48656C6C6F21 -> `Hello!`

По такому же принципу:
б) 0x68454C4C4F21 -> `hELLO!`
в) 0x436F6D70757465727321 -> `Computers!`
г) 0x4C432D32 -> `LC-2`

## 2.44

*Задача*: какие операции можно использовать для преобразования бинарного представления числа 3 (0000 0011) в ASCII представление числа `'3'` (0011 0011)? А для бинарного числа 4? А для любой другой цифры?

*Решение*: Если проанализировать каждый ASCII код цифр, то можно заменить, что последние 4 бита кода описывают как раз число в бинарном представлении. В таком случае, достаточно будет сложения бинарного представления цифры с битовым шаблоном 00110000.
Для 0, 0011 0000 + 0000 0000 = 0011 0000 -> `'0'`
Для 6, 0011 0000 + 0000 0110 =  0011 0110 -> `'6'` 
и так далее

## 2.45

*Задача*: Переведите следующие беззнаковые бинарные числа в hex формат (шестнадцатиричные)

*Решение*:
а) 1101 0001 1010 1111 -> D1AF
б) 0001 1111 -> 1F
в) 1 -> 1
г) 1110 1101 1011 0010 -> EDB2

## 2.46

*Задача*: Переведите следующие hex числа в бинарный вид

*Решение*:
а) 0x10 -> 0001 0000
б) 0x801 -> 1000 0000 0001
в) 0xF731 -> 1111 0111 0011 0001
г) 0x0F1E2D -> 0000 1111 0001 1110 0010 1101
д) 0xBCAD -> 1011 1100 1010 1101

## 2.47 

*Задача*: Переведи следующие hex-числа, представляющие числа с дополнительным кодом к десятичному виду.

*Решение*: Перед переводом в десятичное систему необходимо каждое число перевести в двоичную

а) 0xF0 -> 1111 0000
1. Реверсировать биты: 0000 1111
2. Прибавить один бит: 0000 1111 + 1 = 0001 0000
3. Перевести в десятичное и добавить знак: -16

б) 0x7FF -> 0111 1111 1111
1. Перевести в десятичное и добавить знак: 2047

в) 0x16 -> 0001 0110
1. Перевести в десятичное и добавить знак: 22

г) 0x8000 -> 1000 0000 0000 0000
1. Реверсировать биты: 0111 1111 1111 1111
2. Прибавить один бит: 1000 0000 0000 0000
3. Переверсти в десятичное и добавить знак: -32768

## 2.48

*Задача*: Преобразуй следующие десятичные числа в hex представления чисел с дополнительным кодом.

*Решение*: Перед переводом в hex необходимо сначала перевести в двоичный дополнительный код.

а) 256 -> 0001 0000 0000 -> 0x100
б) 111 -> 0110 1111 -> 0x6F
в) 123 456 789 -> 0111 0101 1011 1100 1101 0001 0101 -> 0x75BCD15
г) -44 -> 1101 0100  -> 0xD4

## 2.49

*Задача*: Выполните сложение следующих чисел. В hex формате представлены числа с 16 битным дополнительным кодом. Представьте ответы также в hex формате.

*Решение*:
а) 0x025B + 0x26DE -> 0000 0010 0101 1011 + 0010 0110 1101 1110 = 0010 1001 0011 1001 -> 0x2939
б) 0x7D96 + 0xF0A0 -> 0111 1101 1001 0110 + 1111 0000 1010 0000 = 0110 1110 0011 0110 -> 0x6E36
в) 0xA397 + 0xA35D -> 1010 0011 1001 0111 + 1010 0011 0101 1101 = 0100 0110 1111 0100 -> 0x46F4

В последнем варианте при бинарном сложении происходит переполнение, результат выходит за диапазон в 16 бит.

## 2.50

*Задача*: Решите следующие примеры с логическими операциями. Ответ запишите в hex формате.

*Решение*:
а) 0x5478 AND 0xFDEA -> 0101 0100 0111 1000 AND 1111 1101 1110 1010 = 0101 0100 0110 1000 -> 0x5468
б) 0xABCD OR 0x1234 -> 1010 1011 1100 1101 OR 0001 0010 0011 0100 = 1011 1011 1111 1101 -> 0xBBFD
в) NOT(  (NOT(0xDEFA)) AND (NOT(0xFFFF))  ) -> NOT(  (NOT(1101 1110 1111 1010)) AND (NOT(1111 1111 1111 1111))  ) = NOT( 0010 0001 0000 0101 AND 0000 0000 0000 0000) = NOT(0000 0000 0000 0000) = 1111 1111 1111 1111
г) 0x00FF XOR 0x325C = 0000 0000 1111 1111 XOR 0011 0010 0101 1100 = 0011 0010 1010 0011 -> 0x32A3


## 2.51

*Задача*: Какое hex представление имеют следующие числа?

*Решение*:
а) 25,672
1. 25 -> 11001
2. 0,672 -> 0.101011000000
0001 1001 . 1010 1100 0000 -> 0x19.AC0

б) 675.625 в IEEE 754 формат
1. 675 -> 1010100011
2. 0.625 -> 0.101
3. 1010100011.101 -> 1.010100011101
4. Знак: 0, так как положительное
5. Мантисса: 9 + 127 = 136 -> 10001000
6. Экспонента: 01010001110100000000000
0 10001000 01010001110100000000000 -> 0x4428E800

в) ASCII символы `"Hello"`
1. `"Hello"` -> 01001000 01100101 01101100 01101100 01101111
0100 1000 0110 0101 0110 1100 0110 1100 0110 1111 -> 0x48656C6C6F

## 2.52

*Задача*: Даны два hex числа 0x434F4D50 И 0x55544552 какие значения они принимают в разных типах данных?

*Решение*:

|                        | 0x434F4D50                              | 0x55544552                              |
| ---------------------- | --------------------------------------- | --------------------------------------- |
| Беззнаковое двоичное   | 0100 0011 0100 1111 0100 1101 0101 0000 | 0101 0101 0101 0100 0100 0101 0101 0010 |
| 1's complement         | 1129270608                              | 1431586130                              |
| 2's complement         | 1129270608                              | 1431586130                              |
| IEEE 754 с float point | 207.302                                 | 1.4587137e13                            |
| ASCII строки           | COMP                                    | UTER                                    |

## 2.53

*Задача*: Заполни таблицу истинности.
Q1 =NOT(A AND B)
Q2 = NOT( NOT(A) AND NOT (B) )


*Решение*:

| A   | B   | Q1  | Q2  |
| --- | --- | --- | --- |
| 0   | 0   | 1   | 0   |
| 0   | 1   | 1   | 1   |
| 1   | 0   | 1   | 1   |
| 1   | 1   | 0   | 1   |

## 2.54

*Задача*: Заполни таблицу истинности.
Q1 =NOT( NOT(X) OR (X AND Y AND Z) )
Q2 = NOT( (Y OR Z) AND (X AND Y AND Z))

*Решение*:

| X   | Y   | Z   | Q1  | Q2  |
| --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 1   |
| 0   | 0   | 1   | 0   | 1   |
| 0   | 1   | 0   | 0   | 1   |
| 1   | 0   | 0   | 1   | 1   |
| 0   | 1   | 1   | 0   | 1   |
| 1   | 0   | 1   | 1   | 1   |
| 1   | 1   | 0   | 1   | 1   |
| 1   | 1   | 1   | 0   | 0   |

# 2.55

*Задача*: 