
## Как ЭВМ делает то, что делает 

Уровни абстракции, через которые проходит задача, поставленная ЭВМ.
Проблема -> Алгоритм -> Язык программирования -> ISA (Instruction Set Architecture) -> Микроархитектура -> Логическая Схема -> Аппаратные устройства

### Проблема
Проблема — это та задача, которую мы хотим поручить на исполнение ЭВМ. Проблема должна быть обозначена однозначно, так как ЭВМ может исполнять только вполне конкретные инструкции. 

## Алгоритм
Алгоритм — это описание шагов, выполняя которые поставленная проблема будет решена. 
Важно, чтобы алгоритм был определяемым — однозначные инструкции; выполняемым — то есть то, для чего можно найти решение (обратный пример: найти самое большое простое число - это невозможно); завершающимся — алгоритм должен завершаться, то есть иметь точку выхода. 
Чаще всего, для решения одной проблемы могут существовать разные алгоритмы. 

## Программа
Следующий шаг - это преобразование алгоритма в программу с помощью языков программирования. Языки программирования - это такой язык, с помощью которого можно можно однозначно описывать инструкции на исполнение ЭВМ.
Существует более 1000 различных языков программирования, которые «заточены» под разные задачи.
Существуют 2-а вида языков программирования: высокого и низкого уровня. Высокой уровень подразумевает, что при его использовании взаимодействие с «железом» сведено к минимуму И в лучшем случае они независимы от компьютера на котором выполняются. Это известные языки: Python, C/C++, Pascal, Fortran, COBOL etc. Языки низкого уровня привязаны к компьютеру и называются языком Ассемблера для этого компьютера.

## ISA
Далее необходимо перевести программу в набор инструкций для компьютера на котором будет исполнятся написанная программа. 

Архитектура набора команд (Instruction Set Architecture, ISA) - (Из Википедии) часть архитектуры компьютера, определяющая программируемую часть ядра микропроцессора. На этом уровне определяются: архитектура памяти, взаимодействие с внешними IO устройствами, режимы адресации, регистры, машинные команды, различные типы внутренних данных (например, int, float etc), обработчики прерываний.

Простыми словами, ISA - это полная спецификация интерфейса между написанными программами и базовым оборудованием ПК, которая должна производить запуск этих программ.

Простая аналогия - педаль газа в автомобиле. Для водителя понятно — нажал на педаль машина едет, но и для механизма машины понятно, что при давлении на педаль необходимо запустить ряд действия для старта движения машины. Разница лишь в том, что в ISA вместо водителя программа, управляющая аппаратным обеспечение компьютера, а вместо механизма машины - оборудование, выполняющее указания.

Термин код операции (opcode) — используется для описания операции; термин операнд — описывает отдельные значения данных. ISA определяет допустимые представления для операндов - типы данных. ISA определяет механизмы для определения нахождения операндов — адресация (addressing mode)

Количество кодов операции, типов данных и режимы адресации зависят от конкретной ISA. Например x86 - ISA используемый в ПК, имеет около 200 кодов операций, больше 12 типов данных и больше 20 режимов адресации. Оно также определяет количество ячеек, составляющих память компьютера и количество отдельных 0 и 1 в каждой ячейке.

Сегодня существует множество различных ISA. Наиболее известный - x86 от Intel 1979 и также проиводимый AMD. И другие: THUMB (ARM), POWER, z/Architecture (IBM), SPARC (Oracle). Они в свою очередь входят в состав более крупных групп, например CISC (Complete Instruction Set Computer - компьютер с полным набором команд) и RISC (Reduced Instruction Set Computer - компьютер с сокращенным набором команд).

Перевод с языка высокого уровня на ISA компьютера обычно выполняется компилятором. Например, для перевода с программы написанной на С понадобится компилятор под x86. Для каждого языка высокого уровня требуется компилятор, написанный под определенную ISA. А вот трансляция **языка** ассемблер (уникального для каждого ПК) на его ISA выполняется с помощью ассемблера.

## Микроархитектура

Продолжая аналогию с автомобилем микроархитектура - это то, что находится под капотом. ISA, вне зависимости от того какой марки машина, знает что центральная педаль - тормоз, а правая - газ. А уж каким именно образом машина понимает что при давлении на газ необходимо передвинуть шестеренку и тд и тп — это задачи микроархитектуры.

Как и с автомобилями, при проектировании микроархитектуры ее разработчики балансируют между стоимостью, эффективностью и энерго-затратами. Например ISA x86 от Intel имела изначальную версию 8086, которая затем изменялась 80386, 80386 и тд. но каждая имела ту же самую ISA (?).

## Логическая схема

Далее необходимо реализовать каждый элемент микроархитектуры из простых логических схем. Здесь разработчик также должен найти компромисс между стоимостью и производительностью.

## Устройства 

И наконец каждая логическая схема реализуется в соответствии с требованиями конкретной используемой технологии. Например, схемы CMOS отличаются от схем NMOS, которые в свою очередь отличаются от схем на основе арсенида. 

# Упражнения

1. Какие два важных утверждения насчет компьютеров?
Первое — все компьютеры (большие и малые, быстрые и медленные, дорогие и дешевые) в состоянии выполнять одни и те же инструкции, при условии что у них есть достаточно памяти и времени. Второй — мы описываем наши проблемы на разговорном языке. А компьютеры решают эти проблемы потоком электронов. Это преобразование — от разговорного языка до потока электронов — является последовательностью семантических преобразований разработанных и улучшенных за последние 70 лет.

2. Может ли язык программирования высокого уровня давать больше инструкций на выполнение компьютеру, чем язык программирования низкого уровня?
Нет. Разница между языками высокого уровня и языками низкого уровня в первую очередь в абстракции. Языки высокого уровня позволяют проще описывать инструкции, а низкого уровня позволяют контролировать что происходит на уровне процессора. Но в конце концов, они все «компилируются» в инструкции, которые ограничены только архитектурой набора команд.

3. Какая трудность при использовании аналоговых компьютеров побуждает использовать цифровые компьютеры?
Главная проблема в точности. Например, аналоговые часы не могут (вероятно могут, но придется применять очень сложные физические свойства) показывать точность времени до миллисекунд, а цифровые могут без особых затрат. Все из-за того, что цифровые машины используют конечный набор цифр или букв, а в физическом мире могут быть отклонения.

4. Назови одну причину, по которой использование натуральных языков невозможно как языков программирования. 
Самая главная причина — это двусмысленность натуральных языков. Языки программирования должны описывать точные инструкции для компьютера. 

5. ![[IMG_0013.png]]

 9. Способны ли натуральные языки описывать алгоритмы?
 Да. Алгоритм — это последовательность действий, которые должны быть понятны в первую очередь человеку, поэтому его можно описать натуральным языком. Уже после того, как алгоритм будет понятен его можно перевести на язык, который должен быть понятен компьютеру (язык программирования).

10. Назовите 3 характеристики алгоритма. 
Первый — алгоритм должен быть **однозначным** (определенным) — все его инструкции имеют однозначное определение. Второе — алгоритм должен быть **эффективно вычисляемым**, то есть каждая инструкция может быть выполнена с помощью компьютера. Третий — алгоритм должен быть **конечным**, то есть всегда должно быть условие, при котором алгоритм завершает работу. 

11. Для трех характеристик алгоритма составьте противопоставления. 
**Однозначность.** Например, инструкция: «Считать строку» не однозначна, так как не понятно откуда считывать строку: из буфера ввода, из текстового файла, из HTTP ответа?
**Эффективная вычислимость**. Если инструкция просит «Вычислить самое большое простое число», то она не эффективна по вычислениям, поскольку она просто не выполнима. 
**Конечность.** Алгоритм выполняется в бесконечном цикле и не предусмотрен выход из него? Алгоритм не конечен.  

13. Два компьютера A и B идентичны за исключением того, что у компьютера А есть инструкция вычитания, а у В нет. При этом у обоих есть инструкции сложения, и у обоих есть инструкции, которые превращают число в отрицательное. Вопрос: какой компьютер может решить больше проблем? Докажите ответ. 
Даже учитывая, что у компьютера В нет инструкции вычитания он может ее воcпроизвести путем преобразования числа (если оно больше нуля) которое нужно вычитать к отрицательному и выполнить инструкцию сложения. Тогда, оба компьютера могут решать одинаковые количество проблем.

14. ![[IMG_0015.jpeg]]
15. Назовите один плюс высокоуровневых языков программирования и один минус. 
Один плюсов высокоуровневых языков программирования может быть кроссплатформенность — программы на таких языки могут выполняться на разных ЭВМ с разными архитектурами. Из минусов можно отменить невозможность с их помощью взаимодействовать с некоторыми низкоуровневыми компонентами ЭВМ. 

16. Назовите как минимум 3 вещи, определяемых ISA
ISA определяются 4 следующих понятия: 
- Код операции (opcode) — описание некоторой операция над операндом
- Операнд (operand) — то, над чем совершается операция и то что обладает типом данных и содержит какое-то конкретное значение по этому типу данных
- Тип данных (data type) — определяет какие операции можно совершать над операндом и какие он может принимать значения.
- Адресация (addressing mode) — способ обращения к участкам памяти для доступа к операндам.

17. Кратко опишите разницу между архитектурой и микроархитектурой. 
Архитектура — описание того, как взаимодействовать с «железом» через набор инструкций и команд. Микроархитектура — непосредственное взаимодействие «железа» между собой через переданные команды. Если микроархитектура соблюдает «контракт» с архитектурой, то программы выполняемые на определенной архитектуре не будут зависеть от микроархитектуры.

18. Сколько ISA реализуется для одной микроархитектуры и наоборот — сколько микроархитектур может существовать для одной ISA
Для одной ISA может существовать разное количество микроархитектур. Например, для ISA x86 существует множество микроархитетур — Intel: Pentium, Core, Nehalem; AMD: K8, Buldozer. Для ISA ARM — Apple: M1, M2; ARM Cortex-A53, Cortex-X1. 
Однако, для одно микроархитектуры может сущестововать только одна ISA.  Например, для микроархитектуры Intel Core реализован только ISA x86, а для ARM Cortex-A78 только ISA ARM. 

19. Перечислите уровни преобразований и приведите примеры для каждого уровня. 
1 - Проблема. Нужно отсортировать список из чисел. 
2 - Алгоритм. Использование алгоритма, который отсортирует список из чисел (напр. пузырьковая сортировка). 
3 - Язык программирования. Написание на языке программирования реализации алгоритма сортировки с возможностью передать на выполнение список необходимых для сортировки чисел. 
4 - ISA. Преобразование кода с языка программирования в машинный код для его исполнения инструкциями ISA данной ЭВМ.
5 - Микроархитектура. Исполнение команд от ISA. 
6 - Логическая схема. Описывает каждый компонент микроархитектуры. 
7 - Устройства. На которых работает логическая схема. 

20. Эти уровни часто называют уровнями абстракции, почему?
Потому что решаемая проблема сводится от более абстрактного понятия — проблема — к более физическому — устройства, на которых решается проблема. И каждый уровень — это абстракция которая может иметь различные реализации. Например, разные алгоритмы сортировки или разная микроархитектура. 

21. Допустим вы идете в магазин и покупаете ПО для обработки текста. В какой форме находится это ПО, оно написано на языке высокого или низкого уровня, на каком ISA компьютера вы сможете его запустить?
Обычно продавец заявляет системные требования для своего ПО, но допустим что их нет — тогда:
- ПО находится в виде программного кода или в скомпилированном для конкретного ISA формате. 
- Оно написано на языке высокого уровня, чтобы была возможность запуска на различных ЭВМ. 
- Если ПО было предварительно переведено в машинный код (скомпилировано), то оно сможет быть запущено только для того ISA для которого было скомпилировано. В другом случае, при наличии на ЭВМ покупателя компилятора для языка программирования этого ПО под ISA этого же ЭВМ оно будет скомпилировано и запущено. 

22. Если на одном из перечисленных уровней преобразования будет необходимо шагнуть на следующий уровень вниз, то с какого бы уровня это было бы сделать тяжелее всего?
С точки зрения ограниченных ресурсов сложнее всего было бы шагнуть с уровня логических схем на уровень устройств — обыватель, как бы идеально он не описал всю систему, может быть ограничен в доступе к материалам для изготовки процессора, графических ускорителей и тп. 

23. Почему ISA вряд ли изменится между последовательными обновлениями микроархитектур?
Для обратной совместимости. Если при каждой новой микроархитектуре будет меняться ISA, то программы перестанут на таких ISA запускаться. Получается, что для каждой новой микроархитектуры придется переписывать все ПО на ЭВМ — это очень трудозатратно и не выгодно не производителем микроархитектур не пользователям.

