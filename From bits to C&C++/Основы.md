
## Как ЭВМ делает то, что делает 

Уровни абстракции, через которые проходит задача, поставленная ЭВМ.
Проблема -> Алгоритм -> Язык программирования -> ISA (Instruction Set Architecture) -> Микроархитектура -> Логическая Схема -> Аппаратные устройства

### Проблема
Проблема — это та задача, которую мы хотим поручить на исполнение ЭВМ. Проблема должна быть обозначена однозначно, так как ЭВМ может исполнять только вполне конкретные инструкции. 

## Алгоритм
Алгоритм — это описание шагов, выполняя которые поставленная проблема будет решена. 
Важно, чтобы алгоритм был определяемым — однозначные инструкции; выполняемым — то есть то, для чего можно найти решение (обратный пример: найти самое большое простое число - это невозможно); завершающимся — алгоритм должен завершаться, то есть иметь точку выхода. 
Чаще всего, для решения одной проблемы могут существовать разные алгоритмы. 

## Программа
Следующий шаг - это преобразование алгоритма в программу с помощью языков программирования. Языки программирования - это такой язык, с помощью которого можно можно однозначно описывать инструкции на исполнение ЭВМ.
Существует более 1000 различных языков программирования, которые «заточены» под разные задачи.
Существуют 2-а вида языков программирования: высокого и низкого уровня. Высокой уровень подразумевает, что при его использовании взаимодействие с «железом» сведено к минимуму И в лучшем случае они независимы от компьютера на котором выполняются. Это известные языки: Python, C/C++, Pascal, Fortran, COBOL etc. Языки низкого уровня привязаны к компьютеру и называются языком Ассемблера для этого компьютера.

## ISA
Далее необходимо перевести программу в набор инструкций для компьютера на котором будет исполнятся написанная программа. 

Архитектура набора команд (Instruction Set Architecture, ISA) - (Из Википедии) часть архитектуры компьютера, определяющая программируемую часть ядра микропроцессора. На этом уровне определяются: архитектура памяти, взаимодействие с внешними IO устройствами, режимы адресации, регистры, машинные команды, различные типы внутренних данных (например, int, float etc), обработчики прерываний.

Простыми словами, ISA - это полная спецификация интерфейса между написанными программами и базовым оборудованием ПК, которая должна производить запуск этих программ.

Простая аналогия - педаль газа в автомобиле. Для водителя понятно — нажал на педаль машина едет, но и для механизма машины понятно, что при давлении на педаль необходимо запустить ряд действия для старта движения машины. Разниц лишь в том, что в ISA вместо водителя программа, управляющая аппаратным обеспечение компьютера, а вместо механизма машины - оборудование, выполняющее указания.

Термин код операции (opcode) — используется для описания операции; термин операнд — описывает отдельные значения данных. ISA определяет допустимые представления для операндов - типы данных. ISA определяет механизмы для определения нахождения операндов — адресация (addressing mode)

Количество кодов операции, типов данных и режимы адресации зависят от конкретной ISA. Например x86 - ISA используемый в ПК, имеет около 200 кодов операций, больше 12 типов данных и больше 20 режимов адресации. Оно также определяет количество ячеек, составляющих память компьютера и количество отдельных 0 и 1 в каждой ячейке.

Сегодня существует множество различных ISA. Наиболее известный - x86 от Intel 1979 и также проиводимый AMD. И другие: THUMB (ARM), POWER, z/Architecture (IBM), SPARC (Oracle). Они в свою очередь входят в состав более крупных групп, например CISC (Complete Instruction Set Computer - компьютер с полным набором команд) и RISC (Reduced Instruction Set Computer - компьютер с сокращенным набором команд).

Перевод с языка высокого уровня на ISA компьютера обычно выполняется компилятором. Например, для перевода с программы написанной на С понадобится компилятор под x86. Для каждого языка высокого уровня требуется компилятор, написанный под определенную ISA. А вот трансляция **языка** ассемблер (уникального для каждого ПК) на его ISA выполняется с помощью ассемблера.

## Микроархитектура

Продолжая аналогию с автомобилем микроархитектура - это то, что находится под капотом. ISA, вне зависимости от того какой марки машина, знает что центральная педаль - тормоз, а правая - газ. А уж каким именно образом машина понимает что при давлении на газ необходимо передвинуть шестеренку и тд и тп — это задачи микроархитектуры.

Как и с автомобилями, при проектировании микроархитектуры ее разработчики балансируют между стоимостью, эффективностью и энерго-затратами. Например ISA x86 от Intel имела изначальную версию 8086, которая затем изменялась 80386, 80386 и тд. но каждая имела ту же самую ISA (?).

## Логическая схема

Далее необходимо реализовать каждый элемент микроархитектуры из простых логических схем. Здесь разработчик также должен найти компромисс между стоимостью и производительностью.

## Устройства 

И наконец каждая логическая схема реализуется в соответствии с требованиями конкретной используемой технологии. Например, схемы CMOS отличаются от схем NMOS, которые в свою очередь отличаются от схем на основе арсенида. 

# Упражнения

1. Какие два важных утверждения насчет компьютеров?
Первое — все компьютеры (большие и малые, быстрые и медленные, дорогие и дешевые) в состоянии выполнять одни и те же инструкции, при условии что у них есть достаточно памяти и времени. Второй — мы описываем наши проблемы на разговорном языке. А компьютеры решают эти проблемы потоком электронов. Это преобразование — от разговорного языка до потока электронов — является последовательностью семантических преобразований разработанных и улучшенных за последние 70 лет.

2. Может ли язык программирования высокого уровня давать больше инструкций на выполнение компьютеру, чем язык программирования низкого уровня?
Нет. Разница между языками высокого уровня и языками низкого уровня в первую очередь в абстракции. Языки высокого уровня позволяют проще описывать инструкции, а низкого уровня позволяют контролировать что происходит на уровне процессора. Но в конце концов, они все «компилируются» в инструкции, которые ограничены только архитектурой набора команд.

3. Какая трудность при использовании аналоговых компьютеров побуждает использовать цифровые компьютеры?
Главная проблема в точности. Например, аналоговые часы не могут (вероятно могут, но придется применять очень сложные физические свойства) показывать точность времени до миллисекунд, а цифровые могут без особых затрат. Все из-за того, что цифровые машины используют конечный набор цифр или букв, а в физическом мире могут быть отклонения.

4. Назови одну причину, по которой использование натуральных языков невозможно как языков программирования. 
Самая главная причина — это двусмысленность натуральных языков. Языки программирования должны описывать точные инструкции для компьютера. 

5. ![[IMG_0013.png]]

 9. Способны ли натуральные языки описывать алгоритмы?
 Да. Алгоритм — это последовательность действий, которые должны быть понятны в первую очередь человеку, поэтому его можно описать натуральным языком. Уже после того, как алгоритм будет понятен его можно перевести на язык, который должен быть понятен компьютеру (язык программирования).

10. Назовите 3 характеристики алгоритма. 
Первый — алгоритм должен быть **однозначным** (определенным) — все его инструкции имеют однозначное определение. Второе — алгоритм должен быть **эффективно вычисляемым**, то есть каждая инструкция может быть выполнена с помощью компьютера. Третий — алгоритм должен быть **конечным**, то есть всегда должно быть условие, при котором алгоритм завершает работу. 

11. Для трех характеристик алгоритма составьте противопоставления. 
**Однозначность.** Например, инструкция: «Считать строку» не однозначна, так как не понятно откуда считывать строку: из буфера ввода, из текстового файла, из HTTP ответа?
**Эффективная вычислимость**. Если инструкция просит «Вычислить самое большое простое число», то она не эффективна по вычислениям, поскольку она просто не выполнима. 
**Конечность.** Алгоритм выполняется в бесконечном цикле и не предусмотрен выход из него? Алгоритм не конечен.  

13. Два компьютера A и B идентичны за исключением того, что у компьютера А есть инструкция вычитания, а у В нет. При этом у обоих есть инструкции сложения, и у обоих есть инструкции, которые превращают число в отрицательное. Вопрос: какой компьютер может решить больше проблем? Докажите ответ. 
Даже учитывая, что у компьютера В нет инструкции вычитания он может ее воcпроизвести путем преобразования числа (если оно больше нуля) которое нужно вычитать к отрицательному и выполнить инструкцию сложения. Тогда, оба компьютера могут решать одинаковые количество проблем.

14. 
