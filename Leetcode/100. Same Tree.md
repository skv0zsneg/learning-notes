## Описание

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

**Input:** p = [1,2,3], q = [1,2,3]
**Output:** true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

**Input:** p = [1,2], q = [1,null,2]
**Output:** false

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

**Input:** p = [1,2,1], q = [1,1,2]
**Output:** false

**Constraints:**

- The number of nodes in both trees is in the range `[0, 100]`.
- `-104 <= Node.val <= 104`

## Решение

#### Мой вариант

Нужно обойти 1 и 2 граф в ширину, складывая значения узлов в список или None, если узла нет, и сравнить списки для p и q. Если списки равны, то графы одинаковы, иначе - нет. 
Наверно не совсем эффективно из-за того, что приходится строить сначала списки по всем графам, а потом их еще и сравнивать. Наверное, можно сделать это "по ходу" прохождения.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        def bfs(node: Optional[TreeNode]) -> list[int]:
            if not node:
                return [None]
            return [node.val, *bfs(node.left), *bfs(node.right)]

        return bfs(p) == bfs(q)

```

#### Из leetcode

Тестируемая функция вызывается как рекурсивная. Внутри проверки:
1. Если оба узла None -> возвращаем False
2. Если оба узла не None и их значения равны, то вызываем эту же функцию 2 раза для сравнения двух поддеревьев левых и правых. Возвращаем булевое AND между результатами этих функций.
3. Во всех остальных случаях возвращаем False
Лучше чем мой вариант, так как не нужно сравнивать списки и пробегаться по всех нодам для их составления.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        
        if p and q and p.val == q.val:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        return False
```