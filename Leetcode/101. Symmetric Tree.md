## Описание

Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

**Input:** root = [1,2,2,3,4,4,3]
**Output:** true

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

**Input:** root = [1,2,2,null,3,null,3]
**Output:** false

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `-100 <= Node.val <= 100`

**Follow up:** Could you solve it both recursively and iteratively?

## Решение

**Рекурсивно.**

Используется рекурсивная функция, которая на каждом шаге проверяет:
- обе ноды `null`? -- возвращаем `true`, так как в таком случае граф симмитричен
- хотя бы одна нода `null`? -- возвращаем `false`, так как один из подграфов уже не существует значит точно не симмитричны
- если:
	- значения у нод равны
	- зеркальны ли левая нода у первой и правая нода у второй 
	- зеркальны ли правая нода у первой и левая нода у второй
	... ноды симмитричны - возвращается `true`

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        
        def is_mirrored(n1, n2) -> bool:
            if not n1 and not n2:
                return True
            if not n1 or not n2:
                return False            
            return (
                n1.val == n2.val 
                and is_mirrored(n1.left, n2.right) 
                and is_mirrored(n1.right, n2.left)
            )

        return is_mirrored(root.left, root.right)
```
![[Pasted image 20251112220806.png]]
> Разобраться с рекурсией - в голове пока что это решение не укладывается.