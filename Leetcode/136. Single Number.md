## Описание

Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

**Example 1:**

**Input:** nums = [2,2,1]

**Output:** 1

**Example 2:**

**Input:** nums = [4,1,2,1,2]

**Output:** 4

**Example 3:**

**Input:** nums = [1]

**Output:** 1

**Constraints:**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- Each element in the array appears twice except for one element which appears only once.

## Решение

Для того, чтобы по памяти и по времени О большое было константой ($O(1)$) необходимо использоваться трюк с операцией XOR. Таблица истинности:

| A   | B   | A XOR B |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 1   | 0   | 1       |
| 0   | 1   | 1       |
| 1   | 1   | 0       |
Если представить два одинаковых целых числа в двоичной системе и произвести над ними операцию XOR, то получится 0. Такой операцией можно проверить являются ли два числа одинаковыми. 100 XOR 100 = 000

В случае задачи - при применении операции XOR на все значения массива останется только то, которое будет присутствовать один раз, то есть то что нам нужно.

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = nums[0]
        for num in nums[1:]:
            res ^= num
        return res
```