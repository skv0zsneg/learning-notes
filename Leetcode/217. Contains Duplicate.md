## Описание

Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.

**Example 1:**

**Input:** nums = [1,2,3,1]

**Output:** true

**Explanation:**

The element 1 occurs at the indices 0 and 3.

**Example 2:**

**Input:** nums = [1,2,3,4]

**Output:** false

**Explanation:**

All elements are distinct.

**Example 3:**

**Input:** nums = [1,1,1,3,3,4,3,2,4,2]

**Output:** true

**Constraints:**

- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

## Решение

#### `set()` из Python (самостоятельно)

Используя структуру `set()` из Python и передав в нее список чисел все дубликаты будут удалены. Таким образом, если мы переданный список `nums` превратим во множество `set(nums)` то если длина массива и множества отличается, то в массиве были дубликаты, иначе - не было.

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) != len(nums)
```

**Сложность**: примерно, $O(n)$ так как мы точно проходимся по всем элементам `nums` чтобы превратить их во множество.
**Память**: наверное $O(k)$ где k - количество элементов в nums.

#### Обход массива (самостоятельно)

Обходим данный `nums`  и складываем во множество как просмотренное каждый элемент. Проверяем есть ли очередной элемент во множестве, если да - то это дубликат можно завершать работу и возвращать `True`. Иначе мы выйдем из цикла, значит дубликата не было - возвращаем `False`.  Выбираем множество для просмотренных элементов чтобы получать элементы по $O(1)$.

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False

```

**Сложность**: $O(n)$ в худшем случае обойдем весь массив
**Память**: $O(k)$ в худшем случае во множество сложим все элементы из переданного `nums`.