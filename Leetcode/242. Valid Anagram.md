
## Описание

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

**Example 1:**

**Input:** s = "anagram", t = "nagaram"

**Output:** true

**Example 2:**

**Input:** s = "rat", t = "car"

**Output:** false

**Constraints:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` and `t` consist of lowercase English letters.

**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

## Решение

#### Мой вариант

Анаграмма, в этом случае, это когда две строчки: 
- имеют одинаковое количество символов
- имеют одинаковое количество каждой из буквы
- расположение не имеет значение

Я придумал пройтись по t и s и сложить данные по ним в мапу, где ключ - символ, а значение количество его повторений. Тогда, если оба словаря для t и s равны - то данные слова аннаграммы друг к другу.

Сложность по памяти тут $O(n)$ так как мы идем по каждой строке длинной $n$.

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        s_data = {}
        for symb in s:
            if symb in s_data:
                s_data[symb] += 1
            else:
                s_data[symb] = 1

        t_data = {}
        for symb in t:
            if symb in t_data:
                t_data[symb] += 1
            else:
                t_data[symb] = 1


        return s_data == t_data
```

#### Из leetcode

Также собираем словарь как и выше, но только для одного s. Затем, мы проходим по символам из t и проверяем:
- если очередной символ из t нет в словаре или счетчик очередного символа уже равен нулю -- возвращаем false и завершаем работу
- у словаря по очередному символу уменьшаем на 1 счетчик -- продолжаем идти по символам из t

Из плюсов такого решения в сравнении с моим - не создается лишний словарь и нет сравнения словарей. Сложность будет такой же $O(n)$ так как мы все также проходим по двум строкам длины $n$.

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        counter = {}
        for char in s:
            counter[char] = counter.get(char, 0) + 1

        for char in t:
            if char not in counter or counter[char] == 0:
                return False
            counter[char] -= 1

        return True
```

#### Читерское Python решение

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```