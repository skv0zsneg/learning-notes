## Описание

Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

1. Each row must contain the digits `1-9` without repetition.
2. Each column must contain the digits `1-9` without repetition.
3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

**Note:**

- A Sudoku board (partially filled) could be valid but is not necessarily solvable.
- Only the filled cells need to be validated according to the mentioned rules.

**Example 1:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

**Input:** board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
**Output:** true

**Example 2:**

**Input:** board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
**Output:** false
**Explanation:** Same as Example 1, except with the **5** in the top left corner being modified to **8**. Since there are two 8's in the top left 3x3 sub-box, it is invalid.

**Constraints:**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` is a digit `1-9` or `'.'`.

## Решение

#### HashMap для хранения колонок, строк и 3x3 блоков

Нужно итерироваться по каждому элементу судоку и проверять его был ли он в просмотренных строках или колонок, а также в блоках 3х3. С последним есть прикол. В отличии от хранения строк и колонок ключ словаря - это кортеж из строки деленной на три колонки деленной на три (без остатка). Почему так? Таким образом мы получаем ID именно внутренних блоков 3х3 и храним значения из них.  

![[Pasted image 20251212221056.png]]

Также, используются множества и словари так как положить элемент и проверить его наличие во множестве - это $O(1)$

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows = collections.defaultdict(set)
        cols = collections.defaultdict(set)
        sub_boxes = collections.defaultdict(set)

        for row_num in range(9):
            for col_num in range(9):
                cell_value = board[row_num][col_num]
                if cell_value == '.':
                    continue

                if (
                    cell_value in rows[row_num]
                    or cell_value in cols[col_num]
                    or cell_value in sub_boxes[(row_num // 3, col_num // 3)]
                ):
                    return False

                rows[row_num].add(cell_value)
                cols[col_num].add(cell_value)
                sub_boxes[(row_num // 3, col_num // 3)].add(cell_value)

        return True

```

**Сложность**: $O(9^2)$ так как в худшем случае мы проходим по всем элеметам двумерного списка (массива)
**Память**: $O(9^2+9^2+9^2)$ для всех выделенных словарей в худшем случае