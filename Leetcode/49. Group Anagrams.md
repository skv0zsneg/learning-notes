## Описание

Given an array of strings `strs`, group the anagrams together. You can return the answer in **any order**.

**Example 1:**

**Input:** strs = ["eat","tea","tan","ate","nat","bat"]

**Output:** [["bat"],["nat","tan"],["ate","eat","tea"]]

**Explanation:**

- There is no string in strs that can be rearranged to form `"bat"`.
- The strings `"nat"` and `"tan"` are anagrams as they can be rearranged to form each other.
- The strings `"ate"`, `"eat"`, and `"tea"` are anagrams as they can be rearranged to form each other.

**Example 2:**

**Input:** strs = [""]

**Output:** [[""]]

**Example 3:**

**Input:** strs = ["a"]

**Output:** [["a"]]

**Constraints:**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.

## Решение

#### Мой вариант

Анаграмма - это кода несколько слов являются равными по количеству букв в слове, но которые стоят в разном порядке. Для группировки должен быть какой-то ключ этой анограмы. В нашем случае идеальным ключом является последовательность букв в отсортированном порядке - такая последовательность будет одинаковая для всех однинаковых анограм.

- Пробегаемся по всем строкам
- Строим по ним ключ
- Кладем очередную строку в подходящей список по ключу
- Выводим получившееся значения

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagram_variants = {}
        for string in strs:
            anagram_key = tuple(sorted(string))
            same_anagrams = anagram_variants.get(anagram_key, [])
            same_anagrams.append(string)
            anagram_variants[anagram_key] = same_anagrams

        return list(anagrams for anagrams in anagram_variants.values())

```

Сложность по времени: $O(m*nlogn)$, где $m$ - это количество строк, которые мы обходим, а $nlogn$ - сложность сортировки в Python. Эти значения перемножаются так как мы делаем сортировку для каждой строки.