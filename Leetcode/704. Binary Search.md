## Описание

Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

**Input:** nums = [-1,0,3,5,9,12], target = 9
**Output:** 4
**Explanation:** 9 exists in nums and its index is 4

**Example 2:**

**Input:** nums = [-1,0,3,5,9,12], target = 2
**Output:** -1
**Explanation:** 2 does not exist in nums so return -1

**Constraints:**

- `1 <= nums.length <= 104`
- `-104 < nums[i], target < 104`
- All the integers in `nums` are **unique**.
- `nums` is sorted in ascending order.

## Решение

Бинарный поиск $O(log n)$ Необходимо иметь два указателя на индексы значений -- левый и правый -- и каждый раз высчитывать средний индекс, брать его значение и сравнивать с искомым. 

Далее три варианта: 
- если предполагаемое значение больше, чем фактическое, то двигаем правую границу влево на предполгаемый индекс - 1 -- продолжаем цикл
- если предполагаемое значение меньше, чем фактическое, то двигаем левую границу вправо на предполгаемый индекс +1 -- продолжаем цикл
- если предполагаемое значение равно искомому - возвращаем индекс target-а - завершаем работу
- если по ходу цикла левая граница стала больше правой - значит искомого числа нет - возвращаем -1 завершаем работу

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:
            guess_idx = (l + r) // 2
            if nums[guess_idx] > target:
                r = guess_idx - 1
            elif nums[guess_idx] < target:
                l = guess_idx + 1
            else:
                return guess_idx

        return -1
```