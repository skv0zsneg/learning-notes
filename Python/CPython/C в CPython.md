
Введение в язык C и его применение в CPython. Ниже про понимание кода и возможности его чтения, но не написания эффективного кода на C.
## Препроцессор С

Препроцессор C обрабатывает исходный код C до того, как он будет обработан компилятором C. Задача препроцессора - создать модуль, который и будет передан на обработку компилятору. Он занимается подменой текста в исходном файле, но также может выполнять простые условные конструкции.

Подмена происходит именно текста - препроцессор ничего не знает о коде на C.

Все команды директивы препроцессору описываются вначале модуля и начинаются с символа `#`.

#### `#include`

Директива `#include` подставляет содержимое файла в исходный файл. Например, в модуле `Modules/_multiprocessing/semaphore.c` в начале есть директива `#include "multiprocessing.h"` - это значит, что на этапе препроцессора (линковки?) в модуль `semaphore.c` будет подставлено содержимое `"multiprocessing.h"`.

У этой директивы могут быть отличия в наименование модулей. Для модулей, окруженных кавычками их поиск будет происходить сначала локально, а затем в системных каталогах (`#include "multiprocessing.h"`), если же модуль обрамлен символами `<...>` то поиск будет выполнять только в системных директориях (`#include <stdio.h>`).

#### `#define`

Ответственность директивы - подмена одного текста на другой.

Эта Директива определяет соответствие между символическим именем и строкой, которая в процессе работы препроцессора подменяется в модуле. Например, `#define SEM_FAILED NULL` подменит все `SEM_FAILED` на `NULL`.

Директива может также передавать параметры так: `#define SEM_CREATE(name, val, max) CreateSemaphore(NULL, val, max, NULL)`. В коде все вызовы
```c
handle = SEM_CREATE(name, val, max)
```
Будут заменены на 
```c
handle = CreateSemaphore(NULL, val, max, NULL)
```

В таких случаях препроцессор ожидает, что вызов `SEM_CREATE` будет как вызов функций с соответствующими параметрами. Такие подстановки обычно называются **макросами**.

#### `#undef`

Директива сбрасывает все определения для препроцессора до нее. Ниже `#undef` все подстановки работать не будут.

#### `#if`

У препроцессора есть возможность использовать условные конструкции для включения или исключения текста из кода по какому-то условию.

Примеры:
```c
#if <макрос>
...
#endif

#if <макрос>
...
#elif <макрос>
...
#else
...
#endif
```

В CPython существуют следующие разновидности `#if`:
- `#ifdef <макрос>` (`#if defined <макрос>`) - текст ниже вставляется в модуль если макрос *определен*.
- `#ifndef <макрос>`  - текст ниже вставляется в модуль если макрос **не** *определен*.
- `#if <макрос>` - текст ниже вставляется в модуль если макрос *определен* **и** результат его работы возвращает `True`. 

#### `#pragma`

Директива содержит инструкции или рекомендации для компилятора

#### `#error`

Директива выводит сообщение на экран и прерывает обработку препроцессора.

## Базовый синтаксис

> Из-за того, что я немного знаком с C часть информации опускается

```c
if (x == 0) {
	int y = 1; // Имя переменной дествительно внутри блоков {}
}

// В однострочных блоках можно опустить {}
if (x == 0)
	printf("Yup, yan!");
printf("Yup, yan out of if block!");

// Тенарны оператор: условие ? true_результат : false_результат
#define SEM_CLOSE(sem) (CloseHandle(sem) ? 0 : -1)
```

**Циклы**

Виды:
1. `for`

```c
for ( <инициализация>; <условие>; <приращение> ) {
	<многократно выполняемый код>
}
```

Пример из `Modules/sha512module.c`:
```c
for (i = 0; i < 8; ++i) {
	S[i] = sha_info->digest[i];
}
```

2. `while` - как в Python
3. `do...while` - первый "проход" будет выполнен всегда, даже если условие ложно (в CPython не используется)

**Указатели**

Указатели - это переменные, которые хранят адрес значения. 

```c
static PyObject *
semlock_release(SemLockObject *self, PyObject *args) {
	<код тела функции>
}
```

`self` содержит адрес значения с типом `SemLockObject` то есть указывает на него. Возвращаемое значение функции также возвращает адрес значения с типом `PyObject`.

В C есть значение `NULL`, которое сообщает, что указатель ни на что не указывает. В CPython есть много проверок указателей на `NULL` и присваивание указателям `NULL`. Такие проверки необходимы, чтобы избежать странного поведение, когда, например, указатель ссылается на не относящееся к программе место. 

**Строки**

Строки в C хранятся как массив типа char для ASCII или wchar для UNICODE. Каждый элемент массива содержит один символ. 

Строки помечаются нуль-терминатором, который обычно помечается как `\0` и расположен в конце строк. Основные строковые операции, например `strlen()` полагаются на нуль-терминатор для определения окончания строки.

Так как строки - это массивы классические Python операции тут не работают. Для копирования строки используется `strcpy()` а для сравнения `strcmp()` (и их аналоги для `wchar`).

**Структуры**

Сложные типы данных в C можно создавать с помощью структур

```c
struct <имя_структуры> {
	<тип> <имя_поля>;
	<тип> <имя_поля>;
	...
}
```

Пример:

```c
struct arraydescr {
	char typecode;
	int itemsize;
	...
}


// Объявление переменной нового типа
struct arraydescr x;
```

Через `typedef`

```c
typedef struct {
	PyObject_HEAD
	SEM_HANDLE handle;
	unsigned long last_tid;
	int count;
	int maxvalue;
	int kind;
	char *name;
} SemLockObject;

// Объявление переменной нового типа
SemLockObject x;
```