## Основы

Есть CPU-bound задачи -- это в основном счетные задачи. Есть IO-bound задачи -- это в основном "ожидающие" задачи (чтение файла, ожидание ответа от socket). `asyncio` предоставляет инструменты для конкуретного выполнения для IO-bound задач (хотя вроде есть API для счетных задач).

Процессы и потоки -- это единицы конкурентности для уровня ОС. Процессы можно использовать как CPU и IO bound задачи, тогда как потоки в Python эффективны только для  IO bound задач из-за GIL, который не дает выполнять интерпретатору Python больше одной инструкции байт кода за один момент времени. asyncio же работает в одном потоке.

В случае если Python делает системные вызовы к неблокирующим сокетам, то можно попросить ОС уведомить нас, когда данные поступят (механизм epoll в Linux). Этим пользуется asyncio в Python, чтобы организовывать конкурентность в одном потоке.

В основе асинхронного Python приложения лежит цикл событий. Это такой цикл, в котором может исполнятся CPU-bound код, пока IO-bound код приостановлен и ждет ответа.

## Основы asyncio

#### Сопрограммы (корутины)

Сопрограммы - это такие "функции", которые могут останавливаться, если нужно для выполнения какой-то операции нужно значительное время. Синтаксис корутины обязывает вместо `def` использовать `async def`, а в месте "приостановки" использовать `await`.

Корутина должна выполнятся в цикле событий, простой вызов возвращает объект корутины.
```python
>>> async def foo(num: int):
...     print("Hey")
... 
>>> foo()
<coroutine object foo at 0x725d39b4f4c0>
```

```python
>>> async def foo(num: int):
...     return num + 1
... 
>>> import asyncio
>>> 
>>> asyncio.run(foo(1))
2
```

`asyncio.run` - это верхнеуровневый интерфейс, позволяющий запускать асинхронное приложение. Она делает такие вещи как: 
1. Запускает переданную в нее корутину
2. Берет на себя заботу об создании и управлении циклом событий
3. Завершает асинхронные генераторы
4. Останавливает выполнение.

#### `await`

Для приостановки выполнения корутины используется ключевое слово `await` за которым идет вызов `Awaitable` объекта (другой корутины в том числе). В момент вызова `await` корутина приостанавливается и передает выполнение вызываемой корутины. После ее завершения выполнение продолжается.

```python
>>> import asyncio
...
>>> async def add_one(num: int):
...    print("add one call")
...    return num + 1
...
>>> async def main():
...    print("before")
...    await add_one(2)
...    print("after")
...
>>> asyncio.run(main())
... 
before
add one call
after
```

На это можно смотреть как на вызов генераторов:
```python
>>> def add_one(num: int):
...     print("add one call")
...     return num + 1
... 
>>> def main():
...     print("before")
...     yield add_one(2)
...     print("after")
... 
>>> for _ in main():
...     pass
... 
before
add one call
after
```