> Rust -- это язык программирования со статической, сильной и неявной типизацией.
## Операции

Унарная операция `-`

```rust
fn main() {
    let a = 1;
    let b = -a;
    let c = -b;
    println!("{}", a);  // 1
    println!("{}", b);  // -1
    println!("{}", c);  // 1
}
```

Деление целочисленных всегда возвращает целочисленный результат, отбрасывая дробные части

```rust
fn main() {
    let a = 1;
    let b = 2;
    println!("{}", a / b);  // 0
}
```

Деление вещественных всегда возвращает вещественное.

```rust
fn main() {
    let a = 0.1;
    let b = 0.2;
    println!("{}", a / b);  // 0.5
}
```

 > Важно помнить про IEEE 754 - результаты могут быть не точными. Компьютер хранит ограниченное число бит для представления бесконечного множества вещественных чисел, это приводит к округлению.
 
```rust
fn main() {
    let a = 0.1;
    let b = 0.2;
    let c = a + b;
    println!("{}", c);  // 0.30000000000000004
    println!("{}", c == 0.3);  // false
}
```

## Преобразование числовых типов

В Rust нельзя производить операции на переменных с разными числовыми типами
```rust
fn main() {
    let a = 0.1;
    let b = 2;
    let c = a / b;  // Ошибка
}
```
```bash
error[E0277]: cannot divide `{float}` by `{integer}`
 --> first-program.rs:4:15
  |
4 |     let c = a / b;  // Ошибка
  |               ^ no implementation for `{float} / {integer}`
  |
```

Однако числовые типы можно преобразовывать с помощью конструкции `переменная as числовой_тип`
```rust
fn main() {
    let a = 0.1;
    let b = 2;
    let c = a / b as f32;
    println!("{}", c);  // 0.05
}
```

Тут нужно быть осторожным, так как возможны потери данных при преобразовании больших чисел с "широким" типом к "узким" типам  и т.п.

```rust
fn main() {
    let a: u16 = 512;  // a = 0000 0010 0000 0000
    let b: u8 = 6;
    let c = a as u8 / b;  // a -> 0000 0000
    println!("{}", c);  // 0
}
```

## Литералы

Литерал - не посредственное представление значения в коде. Например, как число 10 записанное на бумаге.

Целочисленные литералы: `10`, `42`, `-5`, `0`.
Литералы с плавающей точкой: `3.14`, `2.0`, `-0.5`.
Булевы литералы: `true`, `false`.
Символьные литералы: `'a'`, `'я'`, `'!'`.
Строковые литералы: `"Привет, мир!"`, `"Rust"`.
Байтовые литералы: `b'A'`, `b'\xFF'`.
Байтовые строковые литералы: `b"Hello"`.

### Префиксы

- Шестнадцатеричный `0x`, `0xAF`
- Восьмеричный `0o`, `0o77`
- Двоичный `0b`, `0b1001`
- Байтовые символы `b'A'` (Понимает только ASCII кодировку, для UTF-8 нужно использовать \xHH Escape последовательности)
- Байтовые строки `b"AbCd"` (Понимает только ASCII кодировку, для UTF-8 нужно использовать \xHH Escape последовательности)

### Суффиксы

 `i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, isize, usize, f32, f64` .
```rust
// Примеры
let a = 123u64;
let b = 321.0f64;  // при этом указывать точку не обязательно
```

### Escape-последовательности

- Новая строка `\n`
- Табуляция `\t`
- Обратный слэш `\\`
- Двойная ковычка `\"`
- Шестнадцатеричная escape последовательность `\xHH`, HH – это две шестнадцатеричные цифры (0-9, A-F)
- Unicode последовательность `\u{XXXXXX}`, `XXXXXX` – это до шести шестнадцатеричных цифр, представляющих кодовую точку Unicode, например `\u{1F600}`

### Необработанные строки

`r"Тут будет контент, который не воспринемает escape последовательности"`

Могут случиться приколы, когда нужно в необработанную строку положить двойную кавычку. В таких случаях синтаксис меняется: `r#"Теперь "можно""#`. А если мне нужно знак `#` туда положить? Тогда существующие `#` удваиваются -> `r##"Теперь #  "можно""##` и так далее

### Формат числе с плавающей точкой

- Десятичная форма `123.321, 0.5`
- Экспоненциальная форма `1.23e20` -> $1.23*10^{20}$, `0.5e-3` -> $0.5 * 10^{-3}$ , `2E+10` -> $2*10^{10}$ 
- Точечная `12.`

Для вывода float чисел в экспоненциальной форме используется специальный синтаксис 
```rust
println!("{:e}", 312.123); // 3.12123e2
println!("{:E}", 312.123); // 3.12123E2
println!("{:.2e}", 312.123); // 3.12e2
```