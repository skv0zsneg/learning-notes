Жадные алгоритмы - это такие алгоритмы, которые на каждом шаге решает оптимальный для этого шага вариант решения (локально оптимальный). В итоге его работы получается оптимально глобальное решение.

Пример с расписанием. Нужно провести максимальное количество уроков так, чтобы они не пересекались.

![[Pasted image 20251018150417.png]]
Здесь мы начинаем с самого раннего урока -- рисование -- и ставим после него тот, который идет после -- математика и  так далее. Таким образом у нас получается решение:

![[Pasted image 20251018150723.png]]

> ⚠️ Жадные алгоримты не всегда работают правильно.

Возьмем другой пример, где нужно поместить различные предметы разной стоимости в рюкзак ограниченной вместимости. Задача - набрать товаров максимальной стоимости.

Пусть есть рюкзак емкостью 50 кг и три предмета: магнитофон 40 кг и 5 000 руб, ноутбук 30 кг и 3 000 руб и гитара 20 кг и 2 500 руб.

Решение жадного алгоритма было бы такое:
1. Взять самый дорогой предмет
2. Взять следующий самый дорогой предмет
3. Продолжать пока емкость рюкзака не закончится

Если мы так сделаем то в рюкзаке у нас будет лежать только магнитофон и мы залутаем 5 000 руб. Но это не лучшее решение! Если бы взяли ноутбук и гитару, то навар был бы 5 500 руб.

Здесь можно начать экспериментировать заменив флаг "самый дорогой" на "самый легкий" но это не будет работать для всех случаев.

> Иногда идеальное -- враг хорошего. Это девиз жадных алгоритмов. Иногда достаточно хорошего решения достаточно.

### Упражнения

#### 8.1
*Задача*: Вы работаете в фирме по производству мебели и поставляете мебель по всей стране. Коробки с мебелью размещаются в грузовике. Все коробки имеют разный размер, и вы стараетесь наиболее эффективно использовать доступное пространство. Как выбрать коробки для того, чтобы загрузка имела максимальную эффективность? Предложите жадную стратегию. Будет ли полученное решение оптимальным?

*Решение*: если под наиболее эффективно использовать доступное пространство подразумевается перевозить как можно больше коробок в одном грузовике, то жадным алгоритмом может быть:
1. Поместить самую маленькую коробку в грузовик.
2. Взять следующую маленькую коробку и поместить ее в грузовик.
3. Продолжать пока место в грузовике не закончиться.

#### 8.2
*Задача*: Вы едете в Европу, и у вас есть семь дней на знакомство с достопри­мечательностями. Вы присваиваете каждой достопримечательности стоимость в баллах (насколько вы хотите ее увидеть) и оцениваете продолжительность поездки. Как обеспечить максимальную стоимость (увидеть все самое важное) во время поездки? Предложите жадную стратегию. Будет ли полученное решение оптимальным?

*Решение*: жадным решением может быть
1. Посетить самое дорогое по баллам место. 
2. Посетить следующее самое дорогое по баллам место.
3. Продолжать пока не закончатся дни.

Однако, этот алгоритм может быть не оптимальным так как более дешевые по баллам места в сумме могут дать больше.

## Задача о покрытии множества

Есть задачи, в которых мы работает с множествами и одним из требований их выполнения является определить наименьшее количество множеств, которые будут содержать все доступные значения.

Такая задача решается очень долго, так как требует составить список всех возможных подмножеств $2^n$  (все возможные комбинации множеств) (степенное множество). Например, только для составления комбинаций для 32 множеств может уйти 13.6 лет.

Как в таком случае можно решить задачу? Жадные или приближенные алгоритмы. Мы не будет составлять все доступны комбинации, будем размышлять проще:

1. Взять множество, покрывающее наибольшее количество значений.
2. Повторять пока все необходимые значения из множеств не будут охвачены.

В таком случае решение приближенным алгоритмом оценивается по 2 пунктам:
- быстрота;
- близость полученного решения к оптимальному.

В случае выше алгоритм будет выполняться за $O(n^2)$, где $n$ - количество множеств.

Пример решения такой задачи для множеств:
```python
def get_best_sets(sets: dict[str, set[int]], vals_needed: set[int]) -> set[str]:
    final_sets = set()
    local_vals_needed = vals_needed.copy()
    while local_vals_needed:
        best_set_name = None
        vals_covered = set()
        for name_set, values_set in sets.items():
            left_to_cover = local_vals_needed & values_set
            # Проверка на наибольшее не охваченное количество значений в каждом множестве.
            # Запоминается то множество, которые охватывает наибольшее количество оставшихся
            # значений из всех.
            if len(left_to_cover) > len(vals_covered):
                best_set_name = name_set
                vals_covered = left_to_cover

        if best_set_name is None:
            raise ValueError(f"There is no set for given vals {vals_needed}")

        local_vals_needed -= vals_covered
        final_sets.add(best_set_name)

    return final_sets


if __name__ == "__main__":
    sets = {
        "A": {1, 2, 3},
        "B": {4, 1, 5},
        "C": {6, 2, 7},
        "D": {2, 3},
        "E": {7, 8},
    }
    vals_needed = {1, 2, 3, 4, 5, 6, 7, 8}
    res = get_best_sets(sets, vals_needed)
    print(res)

```

## NP-полные задачи

NP-полные задачи (NP - non-deterministic polynomial) -- это такие задачи, которые можно решить быстрее с помощью "жадного" алгоритма, чем с помощью честного перебора всех возможных варинатов для поиска наилучшего, так как последнее сводится к экспоненциальной по времени сложности.

К таким задачам относятся задача о покрытии множества (выше) и задача о коммивояжере.

Задача о коммивояжере сводится к поиску наикротчайшего в сумме пути для посещения всех доступных городов. Если перебирать каждый возможный маршрут для разного количества городов будет обнаружена факториальная зависимость:

| Городов | Маршрутов |
| ------- | --------- |
| 1       | 1         |
| 2       | 2         |
| 3       | 6         |
| 4       | 24        |
| 5       | 120       |
| ...     | ...       |
| 10      | 3 628 800 |

## Определение NP-полных задач

В целом, определить является ли задача NP-полной довольно сложно. Но можно ориентироваться на следующие признаки:
- ваш алгоритм работает быстро при малом количестве элементо, но замедляется при большом;
- формулировка "все комбинации X";
- приходится вычислять все комбинации X так как задачу не удается разбить на более мелкие подзадачи;
- если в задача встречается некоторая последовательность (например, городов) или некоторое множество (например, радиостанций);
- можно переформулировать задачу как коммивояжера или покрытия множества.

## Упражнения

*Задача*: Почтальон должен доставить письма в 20 домов. Ему нужно найти кратчайший путь, проходящий через все 20 домов. Является ли эта задача NР-полной?

*Решение*: Эту задачу можно переформулировать в задачу о коммивояжере, а также для поиска идеального решения необходимо перебрать 20! (2,432902008×10¹⁸) вариантов - это очень много и займет много времени. Задача является NP-полной.

---
*Задача*: Имеется задача поиска максимальной клики в множестве людей (кли­кой называется множество людей, каждый из которых знаком со всеми остальными). Является ли эта задача NР-полной?

*Решение*: Да. Так сказала книга.

---

*Задача*: Вы рисуете карту США, на которой два соседних штата не могут быть окрашены в одинаковый цвет. Требуется найти минимальное количество цветов, при котором любые два соседних штата будут окрашены в разные цвета. Является ли эта задача NР-полной?

*Решение*: Да. Для решения задачи необходимо было бы представить каждый штат как узел и для каждого узла добавить ребра - соседи штатов. Таким образом, нужно было бы пройтись от каждого узла по всем остальным подбирая цвета. Это похоже на задачу о коммивояжера.