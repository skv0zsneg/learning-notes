Жадные алгоритмы - это такие алгоритмы, которые на каждом шаге решает оптимальный для этого шага вариант решения (локально оптимальный). В итоге его работы получается оптимально глобальное решение.

Пример с расписанием. Нужно провести максимальное количество уроков так, чтобы они не пересекались.

![[Pasted image 20251018150417.png]]
Здесь мы начинаем с самого раннего урока -- рисование -- и ставим после него тот, который идет после -- математика и  так далее. Таким образом у нас получается решение:

![[Pasted image 20251018150723.png]]

> ⚠️ Жадные алгоримты не всегда работают правильно.

Возьмем другой пример, где нужно поместить различные предметы разной стоимости в рюкзак ограниченной вместимости. Задача - набрать товаров максимальной стоимости.

Пусть есть рюкзак емкостью 50 кг и три предмета: магнитофон 40 кг и 5 000 руб, ноутбук 30 кг и 3 000 руб и гитара 20 кг и 2 500 руб.

Решение жадного алгоритма было бы такое:
1. Взять самый дорогой предмет
2. Взять следующий самый дорогой предмет
3. Продолжать пока емкость рюкзака не закончится

Если мы так сделаем то в рюкзаке у нас будет лежать только магнитофон и мы залутаем 5 000 руб. Но это не лучшее решение! Если бы взяли ноутбук и гитару, то навар был бы 5 500 руб.

Здесь можно начать экспериментировать заменив флаг "самый дорогой" на "самый легкий" но это не будет работать для всех случаев.

> Иногда идеальное -- враг хорошего. Это девиз жадных алгоритмов. Иногда достаточно хорошего решения достаточно.

### Упражнения

#### 8.1
*Задача*: Вы работаете в фирме по производству мебели и поставляете мебель по всей стране. Коробки с мебелью размещаются в грузовике. Все коробки имеют разный размер, и вы стараетесь наиболее эффективно использовать доступное пространство. Как выбрать коробки для того, чтобы загрузка имела максимальную эффективность? Предложите жадную стратегию. Будет ли полученное решение оптимальным?

*Решение*: если под наиболее эффективно использовать доступное пространство подразумевается перевозить как можно больше коробок в одном грузовике, то жадным алгоритмом может быть:
1. Поместить самую маленькую коробку в грузовик.
2. Взять следующую маленькую коробку и поместить ее в грузовик.
3. Продолжать пока место в грузовике не закончиться.

#### 8.2
*Задача*: Вы едете в Европу, и у вас есть семь дней на знакомство с достопри­мечательностями. Вы присваиваете каждой достопримечательности стоимость в баллах (насколько вы хотите ее увидеть) и оцениваете продолжительность поездки. Как обеспечить максимальную стоимость (увидеть все самое важное) во время поездки? Предложите жадную стратегию. Будет ли полученное решение оптимальным?

*Решение*: жадным решением может быть
1. Посетить самое дорогое по баллам место. 
2. Посетить следующее самое дорогое по баллам место.
3. Продолжать пока не закончатся дни.

Однако, этот алгоритм может быть не оптимальным так как более дешевые по баллам места в сумме могут дать больше.

## Задача о покрытии множества

Есть задачи, в которых мы работает с множествами и одним из требований их выполнения является определить наименьшее количество множеств, которые будут содержать все доступные значения.

Такая задача решается очень долго, так как требует составить список всех возможных подмножеств $2^n$  (все возможные комбинации множеств) (степенное множество). Например, только для составления комбинаций для 32 множеств может уйти 13.6 лет.

Как в таком случае можно решить задачу? Жадные или приближенные алгоритмы. Мы не будет составлять все доступны комбинации, будем размышлять проще:

1. Взять множество, покрывающее наибольшее количество значений.
2. Повторять пока все необходимые значения из множеств не будут охвачены.

В таком случае решение приближенным алгоритмом оценивается по 2 пунктам:
- быстрота;
- близость полученного решения к оптимальному.

В случае выше алгоритм будет выполняться за $O(n^2)$, где $n$ - количество множеств.

Пример решения такой задачи для множеств:
```python
def get_best_sets(sets: dict[str, set[int]], vals_needed: set[int]) -> set[str]:
    final_sets = set()
    local_vals_needed = vals_needed.copy()
    while local_vals_needed:
        best_set_name = None
        vals_covered = set()
        for name_set, values_set in sets.items():
            left_to_cover = local_vals_needed & values_set
            # Проверка на наибольшее не охваченное количество значений в каждом множестве.
            # Запоминается то множество, которые охватывает наибольшее количество оставшихся
            # значений из всех.
            if len(left_to_cover) > len(vals_covered):
                best_set_name = name_set
                vals_covered = left_to_cover

        if best_set_name is None:
            raise ValueError(f"There is no set for given vals {vals_needed}")

        local_vals_needed -= vals_covered
        final_sets.add(best_set_name)

    return final_sets


if __name__ == "__main__":
    sets = {
        "A": {1, 2, 3},
        "B": {4, 1, 5},
        "C": {6, 2, 7},
        "D": {2, 3},
        "E": {7, 8},
    }
    vals_needed = {1, 2, 3, 4, 5, 6, 7, 8}
    res = get_best_sets(sets, vals_needed)
    print(res)

```