Граф - это модель, представляющая набор связей в виде узлов и соединяющих их ребер. Ребра могу быть направленные и двунаправленные. Из одного узла может выходить больше одного ребра.

Алгоритм для решение задач поиска кратчайшего пути называется поиском в ширину. Возможные шаги для решение задачи таким способом: 1. Смоделировать задачу в виде графа; 2. Решить задачу методом поиска в ширину.

Такой алгоритм может ответить на 2 типа вопросов: 1. Существует ли путь от узла А к узлу Б; 2. Как выглядит кратчайший путь от узла А к узлу Б.

Алгоритм поиска в ширину ищет среди ближайших узлов, как бы, расширяясь от выбранного узла в процессе поиска. Сначала проверяются ближайшие узлы (1 уровень), а затем узлы узлов (2-й уровень), а затем узлы узлов узлов (3-й уровень) и тд.

Для того, чтобы поиск шел по уровням, необходимо складывать просматриваемые узлы в специальную структуру данных, называемую очередью FIFO (First In, First Out). Первый пришедший объект в очередь - выйдет первым.

Также, существует очередь LIFO (Last In First Out), которая также называется стеком. Последний пришедший в эту очередь объект выйдет первым. 

![[Pasted image 20250330202118.png]]

> В Pyhton, и не только, существует стек вызовов - это когда каждая вызываемая функция внутри другой функции встает в очередь LIFO. Таким образом, задачи которые могут требовать решения с помощью очереди LIFO могут использовать рекурсивные функции.

Граф, у которого нет ребер, указывающих в обратном направлении называются деревом.

## Реализация Графа

Реализация графа в Python может быть представлена как словарь с ключами - строками (узлами), а значениями - списком из строк (соединений с другими узлами).

```python
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []
```

## Реализация алгоритма

```python
@dataclass
class Person:
    name: str
    is_mango_seller: bool = False


def breadth_first_search_mango_seller(
    start_node: Person,
    graph: dict[Person, list[Person]],
) -> Person | None:
    # Очередь из узлов, которые нужно проверить
    nodes_to_check = deque()
    # Список просмотренных узлов, чтобы не попасть в цикл
    searched_nodes = set()

    # Наполняем очередь узлами, соседними с стартовым (start_node)
    nodes_to_check.extend(graph[start_node])
    # Добавляем стартовый узел в "просмотренные", так как мы точно знаем что его нам
    # не нужно проверять
    searched_nodes.add(start_node)
    # Пока очередь не будет пуста
    while nodes_to_check:

        # Получаем первый слева узел и...
        possible_mango_seller = nodes_to_check.popleft()
        # ...проверяем, есть ли он в "просмотренных" узлах
        if possible_mango_seller in searched_nodes:
            # Если есть, не проверяем его и идем к следующему узлу
            continue
        # Если нет, кладем его в список просмотренных и начинаем проверку
        searched_nodes.add(possible_mango_seller)

        # Проверяем является ли узел искомым (продавцом манго)
        if possible_mango_seller.is_mango_seller:
            # Если да, узел найден - алгоритм завершен
            return possible_mango_seller
        # Если нет, добавляем в очередь для просмотра узлы, связанные с текущим
        nodes_to_check.extend(graph[possible_mango_seller])

    # Здесь мы можем оказаться, если очередь стала пуста. Это значит, что от начального узла
    # не удалось найти искомого
    return None

```

## Выводы

- Алгоритм поиска в ширину позволяет определить, существует ли путь из А в Б.
- Если путь существует, то алгоритм может помочь найти кратчайший путь.
- Если в задаче требуется найти "кратчайшее Х", возможно может решить ее поиском в ширину, смоделировав ее как граф.
- В ненаправленных графах стрелок нет, а отношение идет в обе стороны.
- Очереди - это FIFO
- Стек - это LIFO
- Для того, чтобы находить кратчайшие пути нужно проверять узлы в правильном порядке. Для этого помогает очередь FIFO.
- Уже проверенные узлы нужно запоминать, чтобы алгоритм не вошел в цикл.