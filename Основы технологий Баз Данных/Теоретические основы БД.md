## Модели данных

Под моделью данных будем понимать систему взаимосвязанных понятий и правил предназначенную для описания структур и свойств данных, используемых (хранимых и обрабатываемых) в информационной системе (СУБД).

В Развитую модель данных входит:

- способы описания данных (типы, как строить сложные структуры данных)
- Способы описания взаимосвязей между объектами
- Средства задания ограничений целостности
- Способы конструированиях операций, которые можно выполнить в рамках модели данных

## Идентификация и изменяемость

Многие свойства и модели данных определяются тем, как можно различать используемые в ней модели. Некоторые модели подразумевают наличие способа идентификации. В этом случае объекты считаются одинаковыми если у них совпадают идентификаторы.

Методы идентификации объекта данных можно разделить так:

- По естественным признакам. Объект реального мира, напр. номер бронирования, биометрические свойства и тп.
- По искусственному значению. Оно генерируется информационной системой, напр. номер документа, идентифицирующего личность.
- По связи объекта. Связь с другим уже идентифицируемым обьектом. Напр. «правое переднее колесо машины» идентифицирует колесо по месту. Ввиду того, что колёса взаимозаменяемые в рамках модели они могут идентифицироваться совпадающими значениями всех атрибутов. Также объекты можно идентифицировать по адресу в памяти ПК.

Для моделей данных важно само наличие идентификатора, а не его природа. Если идентификатор отсутствует, то единственным способом проверить на равенство объектов остаётся проверка на совпадение каждого его элемента. Если хотя бы одно значение отличается объекты считаются различными. В таких моделях объекты изменятся не могут — можно заменить один объект на другой, но изменить их невозможно.

## Навигация и поиск по значениям

Основные классы поисковых операций:

- **Навигационный доступ**. Переход от объекта к объекту выполняется за счёт ссылок на объекты. Этими ссылками могут быть Foreign Key в реляционных БД.
- **Поиск по значениям**. Ассоциативный поиск. Результат — это обычно набор данных, удовлетворяющим условиям поиска.

Многие модели допускают использования обоих вариантов поиска.

## Объекты и коллекции объектов

Системы основанные на реляционных моделях в том числе postgresql обеспечивают высокую эффективность массового извлечения данных, но могут оказаться значительно менее эффективными при обработке отдельных объектов данных.

## Свойства моделей данных

Для объектных моделей показателями эффективностями были навигационный способ доступа и ориентации на обработку отдельных данных. После появления в 1970 реляционной модели эти критерии для оценки эффективности реализации не подходили.

Стало очевидно, что повышать эффективность старыми критериями невозможно.

---

## Реляционная модель

Реляционная модель появилась в 1970х р работах Э. Кодда и у других. Большую популярность модель приобрела за счёт К. Дейта. В течении десятилетий модель развивалась как чисто теоретический концепт. При это подчеркивалось, что реляционная модель не решает вопросы организации хранения данных и эффективная реализация реляционной модели данных невозможна.

В последующие десятилетия удалось в ходе исследований создать субд, основанные на реляционной модели. Такие системы сейчас широко используются в том числе PostgreSQL.

Радикальные переменны в сторону реляционных субд произошли путём изменения критериев оценивания эффективности и требования к системам.

Было: эффективность доступа к отдельным объектам данных и навигация между ними.

Стало: эффективность массовой обработки данных и поиск по значениям атрибутов (ассоциативный поиск)

## Основные понятия реляционной модели данных

**Домены**

В реляционной теории БД домен — это множество некоторых значений. При этом каждое значение является скалярной константой. Скалярное значит, что структура значений не рассматривается в рамках модели и любые изменения приводят просто к новым значениям, а не изменению старых.

Кроме того, для любого домена должно существовать бинарное отношение равенства, чтобы можно было сравнивать значения домена между собой на равенство. Это необходимо для сравнения, например, с константными в запросе.

Помимо проверки на равенство ещё могут быть другие операции: сравнения <> ≤ ≥ или арифметические + - * / или функции принимающие скалярные значения.

В общем домены — это как абстрактный тип данных в ЯП определяющий набор операций для его наследников. Единственная разница значения доменов — скалярны. Примеры доменов: натуральные числа, числа с плавающей точкой, строки, символы, дата и время и даже длины, координаты, веса и тп.

## Отношения, атрибуты и кортежи

Отношение — это как функции в ЯП с ключевыми аргументами. Ключевые аргументы в свою очередь — это атрибуты, значения этих атрибутов соответствуют какому либо домену. Перечень ключевых аргументов с их значениями есть кортеж.

Только сочетание отношение + кортеж может говорить о истинности некоторого факта.

Пример:

exam(name=‘John’, grade=5, course=‘Введение в БД’)

По классике отношения принято обозначать ввиде таблицы следующим образом:

|атрибут1|атрибутN|
|---|---|
|Значение домена ij|Значения домена I+1j|
|Значение домена ij+1|Значение домена I+1 j+1|

В случае такого отображения: название таблицы — это отношение, колонки задают атрибуты, значения в колонках принадлежат доменам, строки таблицы — это кортежи.

## Реляционная алгебра

Одна из причин успеха реляционной модели — возможность применения операций, благодаря которым создаются новые отношения и использование новых отношении в других операциях.

В реляционной модели те операции, которые применяются к отношениям, называются реляционной алгеброй.

Почти все операции реляционной алгебры явл. частичными (т.е. определены не для любых аргументов или их комбинаций.

**Теоретико-множественные операции**

Из-за того, что кортежи образуют множества можно применять обычные теоретико-множественные операции к любой паре отношений, имеющих одинаковые схемы (такие операции связаны с логическими операциями булевой алгебры)

Существуют следующие операции:

`UNION` Объединение. В результат включаются кортежи входящие в первый ИЛИ во второй аргумент.

`INTERSECT` Пересечение. Результат содержит только кортежи, входящие в первый И второй аргумент.

`EXCEPT` Разность. Результат содержит кортежи, входящие в первый И НЕ входящие во второй аргумент.

Комбинируя эти операции можно строить другие выражения (производные алгебраических отношений), например логическую XOR модно реализовать следующим образом:

`(R UNION S) EXCEPT (R INTERSECT S)`

**Унарные операции (Операции с одним аргументом)**

Такие операции позволяют выделить из отношения ту информацию, которая нужна данному приложению в данный момент.

`PROJ` - операция проекции, включает в результат подмножестве атрибутов отношения, переданного в качестве атрибутов. E.g. `PROJ [name, course] exams` - получилось отношение только с переданными атрибутами name и course.

При этом все дубликаты значений атрибутов, которые могут возникнуть при такой операции, исключаются. В реализациях нужно указывать оставлять дубликаты или нет.

`FILTER` - операция фильтрации по атрибутам отношения. Простое условие состоит из атрибута, который сравнивается с другим атрибутом или константой в свою очередь получившиеся блоки могут соединятся логическими операторами AND OR NOT. Условие может быть заключено в скобки. `FILTER [ course=’Анализ данных’ AND grade=5 ] exams`

**Произведение и соединение**

Есть операция соединения `PROD` результатам которой являются пары из кортежей каждого первого со вторым отношения.

Самое полезная операция — соединения `JOIN`. Она проверят на равенство значений атрибутов в отношениях и соединяет их в одно отношение с «относящимися» друг к другу атрибутами. E.g. `exams JOIN [course=title] courses`

По сути операция соединения — это комбо из операций произведения и фильтрации.

## Свойства операций реляционной алгебры

Основные алгебраические тождества, справедливые для операций реляционной алгебры.

- Коммутативность. Операции объединения, пересечения, произведения и соединения коммутативны.

Например: `R UNION S = S UNION R`

`R JOIN S = S JOIN R`

- Ассоциативность. Операции пересечения, объединения, произведения и соединения ассоциативны.

Например: `R UNION (S UNION T) = (R UNION S) UNION Т`

`R JOIN (S JOIN T) = (R JOIN S) JOIN T`

- Дистрибутивность. Пары операций объединения, пересечения, произведения (или соединения) подчиняются дистрибутивными законам.

Пересечение дистрибутивно относительно объединения: `R INTERSECT (S UNION T) = (R INTERSECT S) UNION (R INTERSECT T)` Объединение дистрибутивно относительно пересечения: `R UNION (S INTERSECT T) = (R UNION S) INTERSECT (R UNION T)` Произведение и соединение дистрибутивны относительно операций объединения и пересечения: `R PROD (S UNION T) = (R PROD S) UNION (R PROD T)` `R PROD (S INTERSECT T) = (R PROD S) INTERSECT (R PROD T)`

Существование алгебраических тождеств позволяет преобразовывать алгебраические выражения в эквивалентные. Чтобы выполнить запрос эффективно СУБД может выбрать среди эквивалентных способов записи запроса в виде выражения такой, выполнение которого требует наименьшее количество вычислительных ресурсов.

## Другие языки запросов

Как было уже сказано одним из требований к СУБД является наличия языка запросов, в идеале, декларативного (что делать а не как). Реляционная алгебра не может считаться декларативным языком, так как алгебраические выражения определяют порядок выполнения операций.

Существуют языки более высокого уровня, позволяющие записать требования к результату запроса. Они называются исчислениями и представляются набором правил.

- В левой части (нвз. головой правила) определяется схема отношения, которое является результатом вычисления правила
- В правой части (наз. тело правила) условие, которому должны удовлетворять кортежи, включаемые в результат вычислений.

Язык SQL занимает промежуточное положение между алгеброй и исчислениями и позволяет использовать формы записи запросов близкие как к алгебраическим выражениям так и к формулам исчисления.

Пример формулы исчисления:

`JoinResult ([x.name](<http://x.name/>), x.course, x.grade, y.title, y.credits) : − x ∈ exams ∧ y ∈ courses ∧ x.course = y.title`

## Нормальные формы

**Функциональная зависимость.** Очень сложная теория проще объяснить примером. д

В отношение `exam` оценка - `grade` - функционально зависит от пары атрибутов этого отношения - `{name, course}`. Потому что одна оценка может относится только к одному студенту и одному курсу, на котором этот студент учится.

При этом очевидно что функциональной зависимости нет между атрибутами `name` и `course`

Потому что любой курс может сдавать несколько студентов и любой студент может сдавать несколько курсов.

Функциональная зависимость изображается так `{name, course} → {grade}`

**Возможный ключ.** Множество атрибутов, от которых функционально зависят все атрибуты отношения — это есть возможный ключ отношения. Т.е. какой-то набор значений по атрибутам зависит от всего набора атрибутов в кортеже. Если этот набор изменится то он уже соответствует другим атрибутам в кортеже.

**Минимальный ключ.** Если после исключения из возможного ключа любого атрибута оставшееся множество атрибутов не является возможным ключом, то это был минимальный ключ.

В отношении может быть несколько минимальный ключей, один из них выбирается в качестве **первичного ключа** отношения. Этот первичный ключ может использоваться для идентификации конкретного кортежа отношения, как и любые другие ключи.

Например, в отношении `exams` единственным минимальным ключом является сочетание атрибутов `{name, course}`. Эта пара атрибутов составляет первичный ключ данного отношения.

**Нормализация**

Наличие нетривиальных функциональных зависимостей может приводить к нежелательным эффектам, которые называют аномалиями.

Пример. В упомянутой выше зависимости `{name, course} → {grade}` есть зависимость от части первичного ключа `{course} → {credits}`. Из-за этой зависимости возникает избыточность: зачётные единицы `credits` появляются столько раз, сколько встречается курс `course`. Также, в таком отношении невозможно хранить информацию о курсе, которые не сдавал ни один студент. Для устранения таких аномалий необходимо вместо такого отношения использовать 2-е его проекции совпадающие с отношениями `exams` и `courses`. Потери информации в данном случае нет, так как получить исходное отношение можно через операцию соединения

«По историческим» причинам отношения, в которых все атрибуты имеют скалярные значения находятся в **первой нормальной форме 1NF**.

Отношения в которых отсутствуют зависимости от неполного ключа (как было выше) называются отношениями во **2-й нормальной форме 2NF**.

Аномалии могут быть вызваны транзитивными зависимостями. Если есть функциональные зависимости X → Y и Y → Z, то существует еще зависимость X → Z. Такие комбинации приводят к аномалиям потому что каждый комплект значений атрибутов из Z будет повторён вместе с значениями атрибутов Y.

Наример, в отношении со схемой `{employer, department, manager}` для каждого сотрудника `employer` указан его отдел `department` и менеджер `manager`. При таком отношении есть избыточность - у всех сотрудников одного отдела менеджер один и тот же.

Для устранения этой избыточности (аномалии) нужно создать две проекции (разбить текущее отношение на 2-а) таким образом, чтобы зависимости, которые являются транизитивными, оказались в разных отношениях. Из примера выше разбиение будет таким: `{employer, department}` и `{department, manager}`. Устранение таких транизитвных зависимостей переводит отношение в **3-ю нормальную форму 3NF**.

Построение схемы реляционной бд (т. е. набора схем отношений)
можно начинать не с определения отношений, а с определения перечня атрибутов и функциональных зависимостей. Есть некоторые алгоритмы, которые имея эту информацию могут построить отношения до 3-й нормальной формы.

**Логическое хранение и структуры хранения** 

Практическое значение нормальных форм и нормализации состоит в том, что они дают критерии, по которым можно оценивать качество логической структуры базы данных. При этом структуры хранения могут отличаться от логической, потому что там учитываются другие критерии. 

Хранение именно логической схемы может привести к усложению выполняемых запросов - вычислительно сложных операций соединений во многих запросах.

Иногда нормализацией считают то, что нормализацией не является. Типичныый пример - замена значений атрибутов на суррогатные идентификаторы с последующем вынесением строковых значений в одельные отношения. В таких решения связь с нормализацией состоит только в том, что оно вводит *иискуственные* транзитивные зависимости.

В реляционной модели данных *все значения являются константами*, они идентифицируют сами себя, и поэтому в рамках этой модели никакой необходимости в дополнительных суррогатных идентификаторах нет. Именно такие проектные решения приводят к излишнему усложнению многих запросов.

## Практические варианты реляционной модели данных

### Неопределенные значения

Одно из отличий практических реализаций реляционной модели от теоретической — использование неопределенных значений атрибутов обычно обозначаемое ключевым словом Null. 

В теоретической модели неопределённые значения не допускаются из-за того, что проводимые с ними операции дают неопределённые значения. 

Хорошей практикой считается запрет на использование неопределенных значений для всех атрибутов за исключением тех, для которых неопределенные значения необходимы. 

### Дубликаты

Ещё одно отличие практической от теоретической реляционной модели — использование дубликатов. В теории дубликатов не должно быть, однако на практике операции по их устранению или проверке на отсутсвие вычислительно затратны и приводят к снижению производительности системы. 

Однако со временем мощности ЭВМ увеличились, что позволило склонятся к логической корректности — т.е. избавление от дубликатов. 

Наличие дубликатов в хранимых таблицах чаще всего является следствием ошибки разработчиков приложения. 

### Дополнительные операции

Ввиду различий из-за неопределенных значений и дубликатов появляется отличие в семантике и алгебраических свойств теоретических реляционных операций в промышленных реализациях реляционных СУБД. 

Проще говоря из-за различий теории и практики появляются некоторые особенности и отличия. 

## Средства концептуального моделирования

Как моделировать схемы БД. Есть варианты UML — более верхнее уровненное проектирование всей системы и «сущность — связь» (Entitty - Relationship, ER) — описывает конкретно свойства данных, используемых в системе. 

Далее будет рассматриваться модель ER так как она лучше описывает данные и их свойства. 

### Модель данных «Сущность — связь»

### Основные понятия

Сущность - описание некоторого объекта реального мира, который может быть четко отделён от других объектов и его описание однозначно связано с этими реальным обьектом. 
Проще говоря — сущности должны быть различимы. 

Сущности могут быть изменяемыми, т.е. могут иметь дополнительные свойства — атрибуты сущности. Значения таких атрибутов могут изменяться. 

Связи — упорядоченная последовательность сущностей, имеет свою идентификацию и может иметь свои собственные атрибуты. 
Пример: связь между студентом и дисциплиной - это экзамен. В таком случае упорядоченный набор сущностей - это (студен, дисциплина) и эта же пара идентифицирует связь, а атрибутами этой связи могут быть оценка и дата ее получения. 

Изображение этой связи в нотации ER:
![[441F3EB5-0CA0-4307-8813-534E307BDE4C.jpeg]]
В ER сущности — это прямоугольники, связи — ромбы, атрибуты — овалы. Бывает что атрибуты включают в фигуру, которой они принадлежат или вовсе не изображают из-за получающейся очень большой диаграммы.

### Ограничение целостности (виды связей)

Самым распространённым видом связи является бинарный — связывающий две сущности. Для них определяются ограничения:
* **1** - в связи может и должна участвовать одна сущность
* **0** - в связи может учавствовать не больше чем одна сущность. 
* **m, n** - в связи может учавствовать ноль или несколько сущностей из одного множества
Ограничение целостности может рассматривается как пара таких символов через двоеточие. 

**Примеры.** 

Каждый сотрудник некоторого предприятия обязательно является сотрудником одного отдела — это связь **1:n один ко многим**. n значит, что несколько сотрудников могут быть связаны с одним отделом, а 1 значит, что каждый сотрудник связан с каким-нибудь отделом и только одним. 

Связь между пассажиром и постоянным клиентом — **0:n**, потому что постоянный клиент может быть пассажиром нескольких рейсов **n** (т.к. он постоянный клиент он пользовался услугами перевозчика неоднократно), но пассажир не обязательно является постоянным клиентом **0**. 

Сотрудник может учавствовать в нескольких проектах и в каждом проекте может учавствовать несколько сотрудников — это **m:n многие ко многим**.

### Наследование

Объекты реального мира могут входить в состав нескольких множеств. Например, любой человек может быть а может и не быть сотрудником мероприятия. 

Такие связи в ER представляются с помощью понятия наследования, обозначаются как **is a** и всегда является бинарной связью **1:0**. 

Требуется так же, что бы идентификаторы связанных сущностей совпадали. Например, если в БД есть студент, то во множестве персон обязательно должна быть сущность  с таким же идентификатором и обязательно связанная с найденной сущностью во множестве студентов. Неформально это будет звучать так: *студент является человеком*.

ER устанавливает, что атрибуты при наследовании не дублируются. Например, сущность персона имеет атрибут дата рождения — у наследованной от неё сущности студент этого атрибута не должно быть. Это наследование атрибутов полезно чтобы указать, что у наследника родительские атрибуты не изменяются. Например, рост и вес человека будет одинаковым вне зависимости от того как рассматривается этот человек: как студент, сотрудник предприятия и т.п.

Тождественность идентификаторов накладывает ограничение на множественное наследование. Оно возможно только в том случае, если имеется общее множество изькоторого наследуется оба наследуемых множества. Напр., множество работающих студентов может наследовать свойства студентов и свойства сотрудников. Это возможно потому что и студенты и сотрудники могут быть и студент и сотрудник являются частью более общей сущности «человек» и следовательно все 4 множества могут иметь общий идентификатор.

### Отображение в реляционную модель

Отображение строится следующим образом:
1. Для каждого множества сущностей строится отношение, атрибутами которого становятся идентификатор и все атрибуты имеющиеся у сущности, входящих в это множество. 
2. Определяются функциональные зависимости атрибутов от идентификатора для каждого построенного отношения.
3. Для каждого множества связей строится отношение атрибутами которого становится идентификатор и все атрибуты связи. Напомним, что идентификатор связи содержит все идентификаторы связываемых сущностей. 
4. Определяются функциональные зависимости атрибутов, полученных из атрибутов связи, от атрибутов, полученных из идентификатора связи. 

Пример.
При перевозке грузов с каждым заказом связана одна сущность партия `party` (отправитель или получатель или физическое или юридическое лицо 1 или несколько и тп). Атрибутами возьмём общее для всех — идентификатор и имя.
Есть сущность заказ `order` из атрибутов будет только вес. 
Атрибутом связи будет между заказом и партией будет, кроме идентификаторов связываемых сущностей (`order` и `party`), роль партии. 
![[C4EEC432-4E6E-462D-8AD0-A46315B1C70C.jpeg]]
При этой диаграмме первичными ключами для сущности `order` будет `order_number`, для `party` — `party_id` а ключом отношения `order_party` — совокупность всех трёх его атрибутов поскольку одна и та же партия может выступать по отношению к грузу в нескольких ролях. E.g. отправитель может быть плательщиком. 
Реляционное отображение: ![[BCB25553-2C8C-4F09-81E9-1A427AFA74BD.jpeg]]
Практические реализации реляционной модели предлагают использование дополнительной таблицы (отношения) со связями 1:n к связанным через n:m сущностям. 

При этом в случае отношений 1:n дополнительное отношение не нужно. Связь выражается проставлением внешнего ключа foreign key (к первичному ключу) в качестве атрибута того отношения, которое является «многим» (n) в отношении 1:n. 

> …пусть множества сущностей R1 и Rn с ключами k1 и kn связаны связью E, которая подчиняется ограничению 1 : n. Ключом для связи будет пара ключей связываемых отношений, однако ключ kn однозначно определяет ключ k1 в силу ограничения целостности.

### Концептуальные объектные модели 

Модель сущность связь не позволяет описывать операции над проектируемыми моделями данных. Сейчас эту потребность может закрывать унифицированный язык моделирования (Unified Modeling Language, UML). Однако получающиеся схемы немного уступают вариантам схемы в модели «сущности связь». Так происходит из-за вынужденных компромиссов для упрощения отображения схемы БД и структуры данных приложения. 

## Объектные и объектно-реляционные модели данных 

В связи с расширением спектра областей применения реляционных СУБД были произведены попытки расширения модели (E.g. отношения не в первой нормальной форме NFNF). 

Это привело к созданию языков программирования с постоянным хранением данных (persistent programming language) и объектных моделей баз даных. В обоих случаях в БД размещаются объекты определяемые в рамках объектной модели языка программирования. Этот подход позволил добиться очень высокой эффективности доступа в режиме навигации: в лучших системах время доступа к постоянно хранимым объектам только в 3-4 раза превышало время доступа к оперативной памяти. 

Ожидалось что объектные бд вытеснят все остальные, но 
это оказалось не возможно по ряду причин:
* БД может использоваться только клиентами написанными на одном языке. 
* Не удаётся создать высокоуровневый декларативный язык запросов 
* Не удаётся обеспечить высокую производительность при массовой выборке данных 

Хоть объектные субд не вытеснили реляционные некоторые концепции объектных стали расширениями реляционных. Такие субд принято называть объектно-реляционными из примеров — PostgreSQL. Некоторыеьыиды таких расширений:
* возможность определения пользовательских типов данных, в том числе структуры.
* Использование коллекции объектов. 

Таким образом можно определять пользовательские скалярные типы, структурные типы (eg геометрические объекты, точки, прямые), коллекции - набор данных определенного типа. 

Существует такая разновидность коллекций:
- set — набор объектов без дубликатов 
- bag — неупорядоченный набор объектов, в котором могут быть дубликаты
- list — упорядочены список объектов
- array — набор объектов с доступом по индексу/индексам

Любая коллекция может быть значением атрибута. 

## Другие модели данных

### Слабоструктурированные модели  данных

Иногда хранение схемы (структуры) данных отдельно от данных нежелательно. Например при передаче документов по сети целесообразно передавать структуру документа вместе с самим документом. В подобных случаях значительная часть данных представлена в виде текста на естественном языке такие данные принято называть слабоструктурированными. 

Самыми популярным форматом слабоструктурированных данных является XML и JSON. Хоть и не предполагалось их использование как хранение данных их тем не менее можно использовать как как модели данных.

В объектно-реляционных субд слабоструктурированные данные могут хранится как значения атрибутов. E.g. в PostgreSQL для этого используются типы данных xml, json и jsonb. 

Существование слабоструктурированных типов данных даёт возможность сочетать их с реляционными языками запросов  E.g. XPath, XQuery, SQL/JSON path). 

### Модели для представления знаний

В системах представления знаний, а также для представления данных часто используется тернарная модель данных, в которой элементарной структурой является тройка вида (объект, атрибут, значение). При этом для записи каждого объекта необходимо столько строк, сколько атрибутов имеет этот объект. 

В таком представление схема (перечень атрибутов) неотделима от данных, что обеспечивает возможность хранения любых объектов без какого либо предварительного описания их структуры. Это даёт большую гибкость представления, которая привлекает многих разработчиков.

С другой стороны, применение тернарного представления существенно усложняет функции приложения и очень существенно влияет на его производительность. 

(Не нашёл примеров таких данных)

### Ключ — значение
Существуют также системы, предназначенные для хранения пар ключ — значение. При этом предполагается что поиск данных возможет только по (первичному) ключу, а интерпретация происходит в приложении. 

Простота такого хранилища — простота начального запуска. Из минусов, практически все функции необходимые для СУБД: 
- сложные структуры данных
- Взаимосвязи между объектами
- Ограничение целостности 
- Высокоуровневые декларативные запросы
- Поиск по значениям неключевых атрибутов
Должны реализовываться в коде приложения, что существенно усложняет разработку.

### Устаревшие модели данных
В некоторых учебниках рассматриваются устаревшие модели данных. Например, сетевая модель данных, язык описания для которой разрабатывался комитетом CODASYL; наиболее широко применявшаяся иерархическая модель данных, реализованная в системе IMS компании IBM.

Возможности сетевой модели данных полностью перекрываются объектными и объектно реляционными моделями данных. А возможности иерархической — средствами XML и JSON.

## Примеры проектирования схемы в модели «сущность — связь»

На практике модель проектирования вида «сущность — связь» отличается от представленного выше и от вида в других учебниках. Сущности представлены в виде прямоугольников, а атрибуты записываются внутри. 

Отсутствуют связи в виде ромбов. — поскольку можно однозначно идентифицировать связи линии соединяющие сущности. Для видов связей многие ко многим вводятся дополнительные сущности выполняющие роль таких связей. На концах линий устанавливается кратность связи (1, N или другими спец символами)

Пример схемы БД предназначенный для хранения информации имеющейся на авиабилетах. 

![[5249383878022522548.jpg]]

Основная сущность в схеме —*бронирование* `bookings`. В момент приема заказа создаётся уникальный номер бронирования `book_ref`, который никогда не изменится и *может служить в качестве идентификатора*.

В каждое бронирование можно включить несколько пассажиров, для каждого из которых создаётся отдельный *билет* `tickets`

Билет может содержать несколько *перелетов* `tickets_flight` соответствующих прямому и обратному рейсу, а также может включать пересадки. Каждый перелёт связан с бронированием  и с *рейсом* `flights`, поэтому в качестве идентификатора перелёта используются комбинация из идентификатора бронирования и идентификатора рейса. 

Рейс идентифицируется номером и датой вылета по расписанию. Он связан с двумя *аэропортами* `airports` отправления и прибытия. Каждый аэропорт имеет уникальный трехбуквенный код (SVO, LED).

При регистрации на рейс выдаётся посадочный талон `boarding_passes`, содержащий номер места в качестве атрибута (в дополнении к необходимой идентификации)

Количество мест `seats` в кабине зависит от модели самолета `aircrafts`, совершающего рейс. Предполагается что каждая модель имеет только одну компоновку салона. 

В этом примере *использованы только естественные ключи*. То есть все значения, использованные для идентификации применяемые в реальных бизнес-процессах и никак не зависящие от информационной системы. Так было решено сделать из-за того, что в реальности фактически применяются неизменные идентификаторы, обеспечивающие уникальность. 

Поэтому введение суррогатных идентификаторов привело бы к некоторой избыточности данных. С другой стороны это приводит к появлению составных ключей: ключи перелёта и посадочного талона содержат по три атрибута. 

На самом деле таблицы не нормализованы. Eg В таблице рейсов аэропорты отправления и прибытия зависят только от номера рейса, но не зависят от даты и времени вылета, то есть имеется зависимость от от неполного ключа. Это значит, что таблица **не** находится во второй нормальной форме. Этот недостаток модели легко устраняется путём добавления новой сущности *маршрут*, который идентифицируется номером рейса (и содержит аэропорты отправления и прибытия, тогда аэропорты отправления и прибытия зависят от 1 первичного ключа — номер рейса, а в перелёте будет находится дата и время вылета). 

Но в данном примере, считается что влияние аномалий ненормализованных схем не существенно. Поскольку таблица невелика по размеру, избыточность тоже невелика, коды аэропортов практически никогда не изменяются, поэтому аномалии обновления также не могут повлиять на работу системы. 

Вариант той же схемы БД, но с использованием суррогатных ключей:
![[5249383878022522549.jpg]]
Эта схема обладает некоторыми недостатками по сравнению со схемой с натуральными ключами. Так при извлечении данных из таблицы рейсов для получения кода аэропортов нужен доступ к таблице аэропортов, хотя коды аэропорты понятны любому специалисту без доп расшифровки. Зависимость от неполного ключа превратилась в транзитивную зависимость — идентификаторы аэропортов отправления и прибытия зависят от номера рейса, однако для нормализации потребуется ввести ещё один суррогат для маршрута. 

При проектирование схемы БД необходимо учитывать ограничения, накладываемые на структуру базы данных средой разработки приложений. При этом неизбежны компромиссы, которые приводят к ухудшению качества схемы БД. 

Один из часто встречаемых компромиссов — использование искусственных (суррогатных) ключей для всех таблиц БД. Это может быть необходимо, если среда разработки не допускает использование никаких типов ключей кроме целочисленных. 

Повсеместное использование суррогатов может приводить к появлению фактических дубликатов (различающихся только искусственными идентификаторами) и как следствие у трудно обнаруживаемым ошибкам в работу приложения. 

Сторонники тотального использования суррогатных ключей отмечают их следующие преимущества:
* гарантируется уникальность идентификаторов объектов так как они генерируются в системе. 
* гарантируется неизменяемости идентификаторов, нет необходимости в тщательном анализе предметной области для выявления неизменяемых идентификаторов
* Исключается необходимость использования составных ключей. 

Схем БД также что и выше, но с применением компромиссных решений: большенство отношений используют естественные ключи, но для некоторых оказалось целесообразно использовать суррогатные.

![[5249383878022522550.jpg]]

Эта же схема будет использована в большинстве промеров дальше. 

---
## Упражнения

### #1
**Докажите, что операции UNION, INTERSECT, PROD, JOIN коммутативны**

Отношение **Билеты**

| ticket_no      | int    |
| -------------- | ------ |
| book_ref       | string |
| passanger_name | string |

и **Бронирование** для примера

| book_ref     | string  |
| ------------ | ------- |
| book_date    | date    |
| total_amount | decimal |

Коммутативность — это такая операция при применении которой на ряд членов в их любом порядке результат не изменится.

Официальная запись: `x ° y = y ° x`
Пример: 2 + 3 = 3 + 2; 2 * 3 = 3 * 2.

---
#### UNION
*В результат включаются кортежи входящие в первый или второй аргумент.*

Пусть есть множество для отношения билеты 

**S**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 3         | "ASG9"   | "Петя"         |
и **R**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 4         | "EWW"    | "Иван"         |

Результатом операции `S UNION R` и `R UNION S`будет отношение:

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 3         | "ASG9"   | "Петя"         |
| 4         | "EWW"    | "Иван"         |

**Пояснения**
- Кортеж `(2, "ASG7", "Вася")` входит и в `S` и в `R` множества что подходит под оба условия - `S` ИЛИ `R` и `R` ИЛИ `S`.
- Кортеж `(3, "ASG9", "Петя")` входит в `S` но НЕ входит в `R` множество, что подходит под оба условия - `S` ИЛИ `R` и `R` ИЛИ `S`.
- Кортеж `(4, "EWW", "Иван")` НЕ входит в `S` но входит в `R` множество, что подходит под оба условия - `S` ИЛИ `R` и `R` ИЛИ `S`.


---
#### INTERSECT
*Результат содержит только кортежи, входящие в первый и второй аргументы.*

Пусть есть множество для отношения билеты 

**S**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 3         | "ASG9"   | "Петя"         |
и **R**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 4         | "EWW"    | "Иван"         |

Результатом операции `S INTERSECT R` и `R INTERSECT S` будет отношение:

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |

**Пояснения**
Кортеж `(3, "ASG9", "Петя")` из `S` нет в `R` и кортеж `(4, "EWW", "Иван")` из `R` нет в `S`. Такая проверка будет проведена при любом положении отношений в операции, следовательно операция коммутативна. Результат - это единственный кортеж появляющийся в обеих множествах - `[(2, "ASG7", "Вася")]`

---
#### PROD
*Прямое декартово произведение (или просто декартово произведение) двух отношений (таблиц) создает новое отношение, которое содержит все возможные комбинации строк из обоих исходных отношений.*

Пусть есть множество для отношения  

билеты **S**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 3         | "ASG9"   | "Петя"         |
и бронирование **R**

| book_ref | book_date | total_amount |
| -------- | --------- | ------------ |
| "ASG7"   | 1/1/1970  | 450          |
| "ASG9"   | 2/12/2020 | 1 050        |

Результатом операции `S PROD R` и `R PROD S` будет отношение:

| ticket_no | book_ref | passanger_name | book_ref | book_date | total_amount |
| --------- | -------- | -------------- | -------- | --------- | ------------ |
| 2         | "ASG7"   | "Вася"         | "ASG7"   | 1/1/1970  | 450          |
| 2         | "ASG7"   | "Вася"         | "ASG9"   | 2/12/2020 | 1 050        |
| 3         | "ASG9"   | "Петя"         | "ASG7"   | 1/1/1970  | 450          |
| 3         | "ASG9"   | "Петя"         | "ASG9"   | 2/12/2020 | 1 050        |

**Пояснения**
Операция порождает отношение, содержащее все атрибуты из обеих отношений `R` и `S`, а также все возможные комбинации каждого множества из `R` с каждым множеством из `S`. Получается, что вне зависимости от порядка отношений в операции `PRDO` результат будет одинаковым, таким образом операция коммутативна.

---
#### JOIN
*Объединяет строки из двух отношений на основе некоторого условия.*

Далее примеры будут для следующих отношений

билеты **S**

| ticket_no | book_ref | passanger_name |
| --------- | -------- | -------------- |
| 2         | "ASG7"   | "Вася"         |
| 3         | "ASG9"   | "Петя"         |
| 4         | "WWE"    | "Катя"         |
и бронирование **R**

| book_ref | book_date  | total_amount |
| -------- | ---------- | ------------ |
| "ASG7"   | 1/1/1970   | 450          |
| "ASG9"   | 2/12/2020  | 1 050        |
| "LOL9"   | 27/07/2024 | 2 600 000    |

Существует 4 типа `JOIN` операций
#### INNER JOIN
*Возвращает только те строки, которые имеют совпадающие значения атрибутов в обоих отношениях.*

Результатом операций `S INNER JOIN R` и `R INNER JOIN S` будет отношение:

| ticket_no | book_ref | passanger_name | book_date | total_amount |
| --------- | -------- | -------------- | --------- | ------------ |
| 2         | "ASG7"   | "Вася"         | 1/1/1970  | 450          |
| 3         | "ASG9"   | "Петя"         | 2/12/2020 | 1 050        |

**Пояснения**
Множество `S` имеет совпадающие значения по атрибуту `book_ref` с множеством `R`, а именно `"ASG7"` и `"ASG9"`. По определению операции в результат включаются только те комбинации множеств, которые имеют эти совпадающие атрибуты.
Раз так, то вне зависимости от порядка множеств в операции `INNER JOIN` порядок не изменится, следовательно **операция коммутативна**.

#### LEFT JOIN
*Возвращает все строки из левого отношения и совпадающие строки из правого отношения. Если нет совпадения, результат будет содержать `NULL` для столбцов из правого отношения.*