## Модели данных

Под моделью данных будем понимать систему взаимосвязанных понятий и правил предназначенную для описания структур и свойств данных, используемых (хранимых и обрабатываемых) в информационной системе (СУБД).

В Развитую модель данных входит:

- способы описания данных (типы, как строить сложные структуры данных)
- Способы описания взаимосвязей между объектами
- Средства задания ограничений целостности
- Способы конструированиях операций, которые можно выполнить в рамках модели данных

## Идентификация и изменяемость

Многие свойства и модели данных определяются тем, как можно различать используемые в ней модели. Некоторые модели подразумевают наличие способа идентификации. В этом случае объекты считаются одинаковыми если у них совпадают идентификаторы.

Методы идентификации объекта данных можно разделить так:

- По естественным признакам. Объект реального мира, напр. номер бронирования, биометрические свойства и тп.
- По искусственному значению. Оно генерируется информационной системой, напр. номер документа, идентифицирующего личность.
- По связи объекта. Связь с другим уже идентифицируемым обьектом. Напр. «правое переднее колесо машины» идентифицирует колесо по месту. Ввиду того, что колёса взаимозаменяемые в рамках модели они могут идентифицироваться совпадающими значениями всех атрибутов. Также объекты можно идентифицировать по адресу в памяти ПК.

Для моделей данных важно само наличие идентификатора, а не его природа. Если идентификатор отсутствует, то единственным способом проверить на равенство объектов остаётся проверка на совпадение каждого его элемента. Если хотя бы одно значение отличается объекты считаются различными. В таких моделях объекты изменятся не могут — можно заменить один объект на другой, но изменить их невозможно.

## Навигация и поиск по значениям

Основные классы поисковых операций:

- **Навигационный доступ**. Переход от объекта к объекту выполняется за счёт ссылок на объекты. Этими ссылками могут быть Foreign Key в реляционных БД.
- **Поиск по значениям**. Ассоциативный поиск. Результат — это обычно набор данных, удовлетворяющим условиям поиска.

Многие модели допускают использования обоих вариантов поиска.

## Объекты и коллекции объектов

Системы основанные на реляционных моделях в том числе postgresql обеспечивают высокую эффективность массового извлечения данных, но могут оказаться значительно менее эффективными при обработке отдельных объектов данных.

## Свойства моделей данных

Для объектных моделей показателями эффективностями были навигационный способ доступа и ориентации на обработку отдельных данных. После появления в 1970 реляционной модели эти критерии для оценки эффективности реализации не подходили.

Стало очевидно, что повышать эффективность старыми критериями невозможно.

---

## Реляционная модель

Реляционная модель появилась в 1970х р работах Э. Кодда и у других. Большую популярность модель приобрела за счёт К. Дейта. В течении десятилетий модель развивалась как чисто теоретический концепт. При это подчеркивалось, что реляционная модель не решает вопросы организации хранения данных и эффективная реализация реляционной модели данных невозможна.

В последующие десятилетия удалось в ходе исследований создать субд, основанные на реляционной модели. Такие системы сейчас широко используются в том числе PostgreSQL.

Радикальные переменны в сторону реляционных субд произошли путём изменения критериев оценивания эффективности и требования к системам.

Было: эффективность доступа к отдельным объектам данных и навигация между ними.

Стало: эффективность массовой обработки данных и поиск по значениям атрибутов (ассоциативный поиск)

## Основные понятия реляционной модели данных

**Домены**

В реляционной теории БД домен — это множество некоторых значений. При этом каждое значение является скалярной константой. Скалярное значит, что структура значений не рассматривается в рамках модели и любые изменения приводят просто к новым значениям, а не изменению старых.

Кроме того, для любого домена должно существовать бинарное отношение равенства, чтобы можно было сравнивать значения домена между собой на равенство. Это необходимо для сравнения, например, с константными в запросе.

Помимо проверки на равенство ещё могут быть другие операции: сравнения <> ≤ ≥ или арифметические + - * / или функции принимающие скалярные значения.

В общем домены — это как абстрактный тип данных в ЯП определяющий набор операций для его наследников. Единственная разница значения доменов — скалярны. Примеры доменов: натуральные числа, числа с плавающей точкой, строки, символы, дата и время и даже длины, координаты, веса и тп.

## Отношения, атрибуты и кортежи

Отношение — это как функции в ЯП с ключевыми аргументами. Ключевые аргументы в свою очередь — это атрибуты, значения этих атрибутов соответствуют какому либо домену. Перечень ключевых аргументов с их значениями есть кортеж.

Только сочетание отношение + кортеж может говорить о истинности некоторого факта.

Пример:

exam(name=‘John’, grade=5, course=‘Введение в БД’)

По классике отношения принято обозначать ввиде таблицы следующим образом:

|атрибут1|атрибутN|
|---|---|
|Значение домена ij|Значения домена I+1j|
|Значение домена ij+1|Значение домена I+1 j+1|

В случае такого отображения: название таблицы — это отношение, колонки задают атрибуты, значения в колонках принадлежат доменам, строки таблицы — это кортежи.

## Реляционная алгебра

Одна из причин успеха реляционной модели — возможность применения операций, благодаря которым создаются новые отношения и использование новых отношении в других операциях.

В реляционной модели те операции, которые применяются к отношениям, называются реляционной алгеброй.

Почти все операции реляционной алгебры явл. частичными (т.е. определены не для любых аргументов или их комбинаций.

**Теоретико-множественные операции**

Из-за того, что кортежи образуют множества можно применять обычные теоретико-множественные операции к любой паре отношений, имеющих одинаковые схемы (такие операции связаны с логическими операциями булевой алгебры)

Существуют следующие операции:

`UNION` Объединение. В результат включаются кортежи входящие в первый ИЛИ во второй аргумент.

`INTERSECT` Пересечение. Результат содержит только кортежи, входящие в первый И второй аргумент.

`EXCEPT` Разность. Результат содержит кортежи, входящие в первый И НЕ входящие во второй аргумент.

Комбинируя эти операции можно строить другие выражения (производные алгебраических отношений), например логическую XOR модно реализовать следующим образом:

`(R UNION S) EXCEPT (R INTERSECT S)`

**Унарные операции (Операции с одним аргументом)**

Такие операции позволяют выделить из отношения ту информацию, которая нужна данному приложению в данный момент.

`PROJ` - операция проекции, включает в результат подмножестве атрибутов отношения, переданного в качестве атрибутов. E.g. `PROJ [name, course] exams` - получилось отношение только с переданными атрибутами name и course.

При этом все дубликаты значений атрибутов, которые могут возникнуть при такой операции, исключаются. В реализациях нужно указывать оставлять дубликаты или нет.

`FILTER` - операция фильтрации по атрибутам отношения. Простое условие состоит из атрибута, который сравнивается с другим атрибутом или константой в свою очередь получившиеся блоки могут соединятся логическими операторами AND OR NOT. Условие может быть заключено в скобки. `FILTER [ course=’Анализ данных’ AND grade=5 ] exams`

**Произведение и соединение**

Есть операция соединения `PROD` результатам которой являются пары из кортежей каждого первого со вторым отношения.

Самое полезная операция — соединения `JOIN`. Она проверят на равенство значений атрибутов в отношениях и соединяет их в одно отношение с «относящимися» друг к другу атрибутами. E.g. `exams JOIN [course=title] courses`

По сути операция соединения — это комбо из операций произведения и фильтрации.

## Свойства операций реляционной алгебры

Основные алгебраические тождества, справедливые для операций реляционной алгебры.

- Коммутативность. Операции объединения, пересечения, произведения и соединения коммутативны.

Например: `R UNION S = S UNION R`

`R JOIN S = S JOIN R`

- Ассоциативность. Операции пересечения, объединения, произведения и соединения ассоциативны.

Например: `R UNION (S UNION T) = (R UNION S) UNION Т`

`R JOIN (S JOIN T) = (R JOIN S) JOIN T`

- Дистрибутивность. Пары операций объединения, пересечения, произведения (или соединения) подчиняются дистрибутивными законам.

Пересечение дистрибутивно относительно объединения: `R INTERSECT (S UNION T) = (R INTERSECT S) UNION (R INTERSECT T)` Объединение дистрибутивно относительно пересечения: `R UNION (S INTERSECT T) = (R UNION S) INTERSECT (R UNION T)` Произведение и соединение дистрибутивны относительно операций объединения и пересечения: `R PROD (S UNION T) = (R PROD S) UNION (R PROD T)` `R PROD (S INTERSECT T) = (R PROD S) INTERSECT (R PROD T)`

Существование алгебраических тождеств позволяет преобразовывать алгебраические выражения в эквивалентные. Чтобы выполнить запрос эффективно СУБД может выбрать среди эквивалентных способов записи запроса в виде выражения такой, выполнение которого требует наименьшее количество вычислительных ресурсов.

## Другие языки запросов

Как было уже сказано одним из требований к СУБД является наличия языка запросов, в идеале, декларативного (что делать а не как). Реляционная алгебра не может считаться декларативным языком, так как алгебраические выражения определяют порядок выполнения операций.

Существуют языки более высокого уровня, позволяющие записать требования к результату запроса. Они называются исчислениями и представляются набором правил.

- В левой части (нвз. головой правила) определяется схема отношения, которое является результатом вычисления правила
- В правой части (наз. тело правила) условие, которому должны удовлетворять кортежи, включаемые в результат вычислений.

Язык SQL занимает промежуточное положение между алгеброй и исчислениями и позволяет использовать формы записи запросов близкие как к алгебраическим выражениям так и к формулам исчисления.

Пример формулы исчисления:

`JoinResult ([x.name](<http://x.name/>), x.course, x.grade, y.title, y.credits) : − x ∈ exams ∧ y ∈ courses ∧ x.course = y.title`

## Нормальные формы

**Функциональная зависимость.** Очень сложная теория проще объяснить примером. д

В отношение `exam` оценка - `grade` - функционально зависит от пары атрибутов этого отношения - `{name, course}`. Потому что одна оценка может относится только к одному студенту и одному курсу, на котором этот студент учится.

При этом очевидно что функциональной зависимости нет между атрибутами `name` и `course`

Потому что любой курс может сдавать несколько студентов и любой студент может сдавать несколько курсов.

Функциональная зависимость изображается так `{name, course} → {grade}`

**Возможный ключ.** Множество атрибутов, от которых функционально зависят все атрибуты отношения — это есть возможный ключ отношения. Т.е. какой-то набор значений по атрибутам зависит от всего набора атрибутов в кортеже. Если этот набор изменится то он уже соответствует другим атрибутам в кортеже.

**Минимальный ключ.** Если после исключения из возможного ключа любого атрибута оставшееся множество атрибутов не является возможным ключом, то это был минимальный ключ.

В отношении может быть несколько минимальный ключей, один из них выбирается в качестве **первичного ключа** отношения. Этот первичный ключ может использоваться для идентификации конкретного кортежа отношения, как и любые другие ключи.

Например, в отношении `exams` единственным минимальным ключом является сочетание атрибутов `{name, course}`. Эта пара атрибутов составляет первичный ключ данного отношения.

**Нормализация**

Наличие нетривиальных функциональных зависимостей может приводить к нежелательным эффектам, которые называют аномалиями.

Пример. В упомянутой выше зависимости `{name, course} → {grade}` есть зависимость от части первичного ключа `{course} → {credits}`. Из-за этой зависимости возникает избыточность: зачётные единицы `credits` появляются столько раз, сколько встречается курс `course`. Также, в таком отношении невозможно хранить информацию о курсе, которые не сдавал ни один студент. Для устранения таких аномалий необходимо вместо такого отношения использовать 2-е его проекции совпадающие с отношениями `exams` и `courses`. Потери информации в данном случае нет, так как получить исходное отношение можно через операцию соединения

«По историческим» причинам отношения, в которых все атрибуты имеют скалярные значения находятся в **первой нормальной форме 1NF**.

Отношения в которых отсутствуют зависимости от неполного ключа (как было выше) называются отношениями во **2-й нормальной форме 2NF**.

Аномалии могут быть вызваны транзитивными зависимостями. Если есть функциональные зависимости X → Y и Y → Z, то существует еще зависимость X → Z. Такие комбинации приводят к аномалиям потому что каждый комплект значений атрибутов из Z будет повторён вместе с значениями атрибутов Y.

Наример, в отношении со схемой `{employer, department, manager}` для каждого сотрудника `employer` указан его отдел `department` и менеджер `manager`. При таком отношении есть избыточность - у всех сотрудников одного отдела менеджер один и тот же.

Для устранения этой избыточности (аномалии) нужно создать две проекции (разбить текущее отношение на 2-а) таким образом, чтобы зависимости, которые являются транизитивными, оказались в разных отношениях. Из примера выше разбиение будет таким: `{employer, department}` и `{department, manager}`. Устранение таких транизитвных зависимостей переводит отношение в **3-ю нормальную форму 3NF**.

Построение схемы реляционной бд (т. е. набора схем отношений)
можно начинать не с определения отношений, а с определения перечня атрибутов и функциональных зависимостей. Есть некоторые алгоритмы, которые имея эту информацию могут построить отношения до 3-й нормальной формы.

**Логическое хранение и структуры хранения** 

Практическое значение нормальных форм и нормализации состоит в том, что они дают критерии, по которым можно оценивать качество логической структуры базы данных. При этом структуры хранения могут отличаться от логической, потому что там учитываются другие критерии. 

Хранение именно логической схемы может привести к усложению выполняемых запросов - вычислительно сложных операций соединений во многих запросах.

Иногда нормализацией считают то, что нормализацией не является. Типичныый пример - замена значений атрибутов на суррогатные идентификаторы с последующем вынесением строковых значений в одельные отношения. В таких решения связь с нормализацией состоит только в том, что оно вводит *иискуственные* транзитивные зависимости.

В реляционной модели данных *все значения являются константами*, они идентифицируют сами себя, и поэтому в рамках этой модели никакой необходимости в дополнительных суррогатных идентификаторах нет. Именно такие проектные решения приводят к излишнему усложнению многих запросов.

## Практические варианты реляционной модели данных

Большинство существующих СУБД имеют различия между теоритической и парктической реляционными моделями. Например, вместо отношений
говорят о таблицах, атрибуты называются колонками, а кортежи — строками (рядами) таблиц.

Далее рассматрваются более существенные различия

### Неопределнные значения
