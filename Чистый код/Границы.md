Для чистой архитектуры характерно то, что внесение изменений обходится без значительных затрат и усилий по переработке.

Для граничного кода необходимо четкое разделение сторон и тесты, определяющие ожидания пользователя. Лучше зависеть от того, что вы контролируете, чем от того над чем вы не властны.

Чтобы не было проблем с границами 3d кода нужно свести к минимуму количество обращений к нему. Для этого можно использовать, например, обертки или паттерн адаптер.

В случае, когда в проекте необходимо использовать сторонний код, написанный и поддерживаемый сторонними разработчиками необходимо для сохранения чистоты определять границы нашего программного кода.

## Использование стороннего кода

Когда используется сторонняя тулза с универсальным API необходимо учитывать, что при ее использовании есть риск передавать не нужное нам поведение клиенту, который можете наломать дров (передача словаря с неизменяемыми данными одного типа, однако словарь имеет возможность добавить данные какого угодно типа в себя и изменять данные в нем).

Для ограничения такой свободы действий можно реализовывать интерфейс, инкапсулируя работу с тулзой и предоставляя только нужное нам поведение. Таким образом скрывается граничный интерфейс тулзы делая код чище.

## Исследование и анализ границ

При интеграции стороннего кода более быстрым способом его внедрения будет являться написание «учебных тестов» — мы быстро глянув API начинаем использовать код так как мы считаем он работает. И по ходу возникновения ошибок уже читаем доку более подробно. Таким образом мы не тратим время на то, что нам не нужно в данный момент, а только на интересующий нас API стороннего кода при этом изолируемся от рабочего кода. Это полезно, когда мы хотим быть уверенными в корректном функционале стороннего кода при обновлении его версий.

Проще говоря — это написание тестов для стороннего кода в нашем проекте для увеличения его стабильности при обновлениях.

## Использование несуществующего кода

Пример полезности проведения границ путём создания интерфейсов к еще неизвестному API и в последствии, когда API становится известным, создания адаптера для него к созданному вначале интерфейсу.

Это полезно, потому что:

- Код проекта не зависит от интерфейса предоставляемого сторонним API
- Поводится граница между кодом проекта и 3d кодом
- Легче проводить тестирование создавая mock объект по интерфейсу стороннего API
- Можно вести разработку, пока стороннее API неизвестно