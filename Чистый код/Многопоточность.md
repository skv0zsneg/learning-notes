Написать чистую многопоточную программу очень сложно.

Многопоточное программирование может рассматриваться как стратегия устранения привязок. В однопоточном программировании что и когда связаны, в многопоточном наоборот. Такое разделение способно кардинально улучшить производительность (не во всех случаях) и структуру приложения за счёт, например, разделения ответственности.

## Мифы и неверные представления

Мифы:

- Многопоточность всегда повышает быстродействие. — Это так только при условии, что большая часть времени процесса простаивает, при распараллеливании скорость работы увеличится.
- Написание многопоточного кода не изменяет архитектуру программы. — Чаще всего изменяет и давольно сильно - однопоточный алгоритм не то же самое что многопоточный.
- При работе с готовыми инструментами, которые используют многопоточность, разбираться в их проблемах не обязательно. — Желательно знать как они работают чтобы избежать проблем одновременного обновления и взаимных блокировок.

Ряд утверждений:

- Многопоточность сопряжена с определенными дополнительными затратами — в производительности и в написании доп кода.
- Правильная реализация многопоточности сложна даже для простых задач
- Ошибки в многопоточном коде обычно не воспроизводятся, поэтому они часто игнорируются.
- Многопоточность часто требует значительных изменений в стратегии проектирования.

## Трудности (на примере Java)

Допустим есть код

```java
public class X {
    private int lastIdUsed;
    public int getIndexId() {
        return ++lastIdUsed;
    }
}
```

Пусть значение `lastIdUsed` будет равно 42. Что будет, если запустить два потока с этим экземпляром и вызвать `getNextIndex()` ?

Возможны 3 исхода:

- Первый поток получает 43, второй 44, `lastIdUsed` равен 44
- Первый поток получает 44, второй 43, `lastIdUsed` равен 44
- Первый поток получает 43, второй 43, `lastIdUsed` равен 43

Удивительный третий результат получается тогда, когда потоки друг друга перебивают. Это происходит из-за того, что в Java в двух потоках одна строчка кода может пойти по разным путям и дать неверный результат. Сколько таких путей зависит от работы JIT компилятора Java. В данном примере существует 12 870 путей выполнения. (Нужно читать/изучать подробнее).

## Защита от ошибок многопоточности

**SRP принцип единой ответственности —** Нужно отделять код, относящийся к реализации многопоточности, от остального кода

**Ограничение области видимости данных** — Нужно серьезно относится к инкапсуляции данных от потоков, нужно жестко ограничивать доступ ко всем общим данным.

**Используйте копии данных** — Способы избегания нежелательных последствий одновременного доступа к данным: скопировать объект и ограничить доступ к копии только для чтения; объекты копируются и накапливаются а затем объединяются в одном потоке. Если копирование объектов позволяет избежать синхронизации в коде, экономия на защитных блокировках быстро окупит доп. затраты на создание объектов и уборку мусора.

**Потоки должны быть как можно более независимы** — Нужно стараться писать код так, чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные совместно с другими потоками/процессами. Нужно разбивать данные на независимые подмножества, с которыми будут работать независимые потоки.

## Знайте модели выполнения

Некоторые базовые определения:

- Связанные ресурсы. Ресурсы с фиксированным размером или количеством, существующие в многопоточной среде (E.g. подключение к БД, буферы чтения и записи).
- Взаимное исключение. В любой момент времени с общими данными/ресурсами может работать только один поток.
- Зависание. Один или несколько потоков приостанавливаются на слишком долгое время (или навсегда). E.g. первым всегда запускается более приоритетный поток, низкоприоритетные простаивают.
- Взаимная блокировка deadlock. Два и более потока бесконечно ожидают завершение друг друга. E.g. каждый поток захватил ресурс, необходимый для продолжения работы другого потока, и каждый поток не может завершится из-за занятого другим потоком ресурса.
- Обратимая (активная) блокировка livelock. Потоки не могут «разойтись» — каждый из потоков пытается выполнить свою работу, но обнаруживает что другой поток стоит у него на пути. Потоки постоянно пытаются продолжить выполнение, но им это не удаётся слишком долго (или никогда)

**Модель производитель-потребитель (Producer-Consumer)**

Один или несколько потоков производителей создают задания и помещают их в очередь или буфер. Один или несколько потоков потребителей извлекают задания из очереди и выполняют их.

Очередь между продюсерами и консьюмерами — это связанный ресурс. Это значит, что продюсеры перед записью должны дождаться свободного места в очереди, консьюмеры должны дождаться заданий в очереди.

Координация между потоками основана на передаче сигналов. Обе стороны должны ожидать оповещения о возможности продолжения работы.

**Модель читатель-писатель**

Если в системе есть общий ресурс, который служит источником для потоков читателей но время от времени обновляется потоками писателями появляется проблема оперативного обновления. Если обновления будут производится недостаточно часто, читатели буду получать устаревшую информацию. Если обновление будет слишком частым, т.е. писатели буду постоянно занимать связанный ресурс читатели редко или вообще никогда не смогут получить данные. Необходимо найти баланс и предотвратить возможные ошибки многопоточного обновления.

**Модель «обедающих философов»**

Представим, что есть круглый стол с большой тарелкой спагетти на ней. Вокруг стола сидят философы и размышляют. Когда кто-то из философов проголодается он берет 2 вилки лежащие слева и справа от него и начинает есть (нужно именно 2 вилки). При этом его соседи, даже если проголодались, не могут начать есть поскольку их вилки, слева у одного и справа у другого, заняты.

Если заменить философов на программные потоки, а вилки на ресурс получается типичная задача многопоточности для многих корпоративных систем.

Большинство проблем многопоточности — это разновидности этих трех моделей. Изучайте алгоритмы самостоятельностей создавайте из реализации, чтобы столкнувшись с этими проблемами быть готовым к их решению.

## Зависимости между синхронизированными методами

Не нужно использовать несколько методов одного совместно используемого объекта :)

Но когда это невозможно существуют три способа решения:

- Блокировка на стороне клиента
- Блокировка на стороне сервера
- Адаптирующий сервер

## Синхронизированные секции должны иметь минимальный размер

Блокировки обходятся дорого их по хорошему нужно избегать. С другой стороны все критические секции должны быть защищены. Следовательно код должен содержать как можно меньше критических секций.

Некоторые хитрюги делают большой участок кода синхронизированным из-за чего падает производительность. Нинада так.

> ℹ️ Синхронизированный имеется ввиду защищённый от одновременного доступа разными потоками.

## Трудность корректного завершены

Написать систему, которая работает бесконечно проще чем систему, работающую в течении какого-то времени а затем корректно завершается. Есть примеры вполне обыденные, показывающееся возможные проблемы (eg взаимная блокировка). Ввиду этого нужно начинать думать о том как корректно завершать многопоточную программу на самых ранних этапах. Проанализируйте существующие так как задача может оказаться сложнее чем кажется.

## Тестирование многопоточного кода

Тестирование сводит к минимуму (но не гарантирует) риски неверной работы кода. В многопоточном приложении ситуация с тестированием сильно усложняется.

Необходимо писать тесты на выявление существующих проблем. Также такие тесты нужно повторять для разных конфигураций и уровней нагрузки. Если при выполнении теста произошла ошибка нужно обязательно обнаружить причину. Не нужно игнорировать ошибку, если она пропадает при повторном запуске тестов.

## Начните с отладки не многопоточного кода

При отладки многопоточном программы нужно начинать с синхронного кода.

## Переключение конфигураций многопоточного кода

Напишите вспомогательный код поддержки многопоточности, который может работать в разных конфигурациях:

- 1, 2, n потоков (не-)изменяющиеся динамически
- Многопоточный код взаимодействует с реальным кодом или темповым заменителем
- Код выполняется с тестовыми заменителями, которые работают быстро, медленно и с переменной скоростью
- Настроить тесты так, чтобы они выполнялись заданное количество раз

## Тестировать многопоточный код, превышающий колиичкство ядер или процессоров

Ага.

## Тестируйте многопоточный код на разных платформах

Каждая операционка по своему управляет потоками.

## Применяйте инструментовку кода для повышения вероятности сбоев

Многопоточная программа может падать раз в 10 000 или более за запуск. Это происходит из-за различных путей выполнения многопоточного кода (у джава точно).

Чтобы такие моменты можно было отлавливать можно использовать инструментовку кода — проставление вызовов ожидания, сна и тп