Чистым должен быть не только код, но и архитектура системы. Агрессивная «всепроникающая» архитектура скрывает логику предметной области и снижает гибкость.

Намерения разработчика должны быть четко выражены на всех уровнях абстракции.

Независимо от того, проектируете ли вы целую систему или ее отдельные модули, помните: используйте самое простое решение из всех возможных.

Про то, как сохранить чистоту на более высоких уровнях — на уровне системы.

## Отделение конструирования системы от ее использования

Два понятия:

- Фаза инициализации. Конструируются объекты и склеиваются зависимости.
- Фаза использования. Логика времени выполнения, которая получает управление после инициализации.

Фаза инициализации есть в каждом приложении. Она является первой из областей ответсвенности (concerns).

Во время вызова конструкторов сложных классов нужно подумать, является ли создание экземпляра удачной идеей именно в этом месте. Возможно, можно использовать уже собранный экземпляр для упрощения работы с зависимостями. В худшем случае, возможно дублирование кода (создание этого объекта повторяется) и/или проблема с тестированием (если создаваемый экземпляр — веб-api-класс, то при тестировании придется постоянно дудосиить какой-то веб-сервис; нужно использовать DIP).

## Отделение main

Один из способов отделения конструирования от использования — переместить конструирование объектов ближе к входной точке приложения. Как на картинке:

![[Pasted image 20240827001524.png]]

Тут в мэйн все зависимости для приложения собираются в мэйн и уже готовые передаются приложению. Косая линия показывает, что приложение ничего не знает про мэйн (DIP). Приложение просто использует собранные объекты в ожидании, что они работают правильно.

## Фабрики

Когда созданием объектов должно управлять приложение можно использовать паттерн абстрактная фабрика. Этот паттерн позволит создавать экземпляры объектов не зная подробностей их конструирования.

Например, можно использовать абстрактный класс фабрику, наследник которого на стороне main собирает объект и возвращает его в приложение. Через этого наследника можно было бы передавать также какие-нибудь аргументы.

![[Pasted image 20240827001548.png]]
## Внедрение зависимостей DI

DIP или DI (Dependency Injection) внедрение зависимостей — механизм отделения конструирования от использования, практическое применение обращения контроля IoC (Inversion of Control) в области управления зависимостями. Таким образом объект соблюдает принцип единственной ответсвенности. Объект не должен брать на себя ответственность за создание экземпляров зависимостей. Вместо него ответственность за это передаётся другому уполномоченному механизму — это обычно входная точка main или специализированный контейнер.

Примером «частичной» реализации внедрения зависимостей является запрос JNDI, когда объект обращается к серверу каталоговой информации с запросом на предоставление сервиса с заданным именем. Пример `MySer mySer = (MySer)(jndiContext.lookup("NameOfMySer));` Таким образом происходит активное разрешение зависимостей.

Класс остаётся абсолютно пассивным — не отвечая за внедрение своих зависимостей. Вместо этого он предоставляет set методы или аргументы конструктора, для передачи зависимостей через них. Таким образом зависимости передаются в местах использования этого класса.

## Масштабирование

Возможность Построить правильную систему с первого раза — миф. Вместо этого сегодня реализуем текущие потребности, а завтра перерабатываем и расширяем систему для реализации новых потребностей. Это есть суть итеративной и пошаговой гибкой разработки. Разработка через тестирование, рефакторинг и получающийся в итоге чистый код обеспечивает работу этой схемы схемы.

Архитектура программных систем может развиваться последовательно, если обеспечить правильное разделение ответсвенности.

## Поперечные области ответсвенности

В некоторых областях архитектура может приближаться к полноценному разделению ответственности, однако такие области как сохранение объектов выходят за рамки естественных границ объектов предметной области. E.g. все объекты могут сохраняться по одной стратегии с использованием субд → определённых имен таблиц, полей и тп.

Для подобных областей используется термин «поперечные области ответственности». Для реализации грамотного построения таких областей можно использовать Аспектно Ориентированное Программирование (АОП).

В АОП специальные модульные конструкции, называемые аспектами, определяют в каких точках системы поведение должно меняться некоторым последовательным образом в соответствии с потребностями определённой областью ответсвенности. В примере с сохранением через субд — объявляется какие объекты, атрибуты и тп должны сохранятся и затем делегируется задачи сохранения своей инфраструктуре сохранения. Изменения вносятся инфраструктурой АОП без вмешательство в целевой код.

Далее рассмотрим 3 аспектно-подобных механизма.

## Proxies (посредники)

Лучше их не использовать короче (стр. 191)

_Далее идут главы с примерами на Java в которых мне сложно разобраться: стр. 192-195_

## Испытание системной архитектуры

Если грамотно организовать архитектуру ее можно будет развивать от простого к сложному, как потребует ситуация, подбирая новые технологии по мере необходимости. Не обязательно сразу создавать «Большой Изначальный Проект» (BDUF, Big Design Up Front (не путать с практикой упреждающего проектирования). Это даже вредно, потому что BDUF снижает возможность адаптации к изменениям из-за психологического нежелания расстонаться с уже проделанными частями работы.

Программные продукты обладают собственной физикой и радикальные изменения в ней могут быть экономически оправданы при условии, что в программном проекте эффективно реализовано разделение ответсвенности.

Это значит, что мы можем начать программный проект с «простого до наивности», но лишенного жестких архитектурных привязок и быстро реализовать пожелания пользователей и уже в последствии добавлять новую инфраструктуру по мере масштабирования.

Этот все не означает, что проект нужно начинать по принципу «как-нибудь в процессе разберёмся». Необходимо уже в начале иметь представление о масштабах, графике проекта, общая структура итоговой системы.

Оптимальная структура состоит из модульных областей ответственности,каждая из которых реализуется на базе простых не к чему не привязанных объектов. Области интегрируются между собой при помощи аспектов или аналогичных средств, минимальным образом вмешивающихся в их работу. Такая архитектура может строится на базе методологи TDD как и программный год.

## Оптимизация принятия решений

Модульность и разделение ответсвенности позволяют децентрализовать управление и принятия решений. В достаточно крупной системе один человек не может принимать все необходимые решения.

Обычно принятие таких решений делегируют самому квалифицированному. Однако гораздо лучше будет отложить принятия решений на самый последний момент. Это необходимо для принятия информативного решения с максимум возможностей. Изначально не привязываясь к архитектуре можно получить множество полезной информации от обратной связи клиентов, подробностей программной области, размышление над текущим состоянием проекта (на поздних стадиях).

Гибкость системы из простых не к чему не привязанных объектов с модульными областями ответсвенности позволять принимать оптимальные, своевременные решения на базе новейшей информации.

## Применяйте стандарты разумно, когда они приносят пользу

Стандарты упрощают повторное использование идей и компонентов, привлечение людей с необходимым опытом, воплощение удачных идей и связывание компонентов. Тем не менее процесс создания стандарта иногда занимает слишком много времени, в результате чего стандарты теряют связь с реальными потребностями людей.

## Системам необходимы предметно-ориентированные языки

Хороший предметно-ориентированный язык (DSL, Domain-Specic Languages) сводит к минимуму «коммуникационный разрыв» между концепцией предметной области и кодом, реализующим эту концепцию.

Предметно-ориентированные языки позволяют выразить в форме простых ни к чему не привязанных объектов все уровни абстракции и все предметные области приложения, от высокоуровневых политик до низкоуровневых потребностей.